var global = (function() {

  var base64Decode = function(string) {
    return window.atob(string);
  };

  return {
    filesystem: {
      root: {
        "package.json": {
          "__stat": {
            "atime": "2013-11-13T20:10:38.000Z",
            "ctime": "2013-11-13T20:03:52.000Z",
            "mtime": "2013-11-13T20:03:52.000Z",
            "size": 311,
            "type": "file"
          },
          "__ref": "a9f52310ba86595371eb254be9bae277"
        },
        "application.coffee": {
          "__stat": {
            "atime": "2013-11-13T20:10:38.000Z",
            "ctime": "2013-11-13T19:41:01.000Z",
            "mtime": "2013-11-13T19:41:01.000Z",
            "size": 2733,
            "type": "file"
          },
          "__ref": "191e63738fc82d8d97b4bc0ab16b2074"
        },
        "node_modules": {
          "__stat": {
            "atime": "2013-11-13T20:10:38.000Z",
            "ctime": "2013-11-13T20:09:49.000Z",
            "mtime": "2013-11-13T20:09:49.000Z",
            "size": 170,
            "type": "directory"
          },
          "testify": {
            "__stat": {
              "atime": "2013-11-13T20:10:38.000Z",
              "ctime": "2013-11-13T20:09:49.000Z",
              "mtime": "2013-11-13T20:09:49.000Z",
              "size": 238,
              "type": "directory"
            },
            "package.json": {
              "__stat": {
                "atime": "2013-11-13T20:10:38.000Z",
                "ctime": "2013-11-13T20:09:49.000Z",
                "mtime": "2013-11-13T20:09:49.000Z",
                "size": 3663,
                "type": "file"
              },
              "__ref": "3d78c3543db35b59635052552b1691e2"
            },
            "node_modules": {
              "__stat": {
                "atime": "2013-11-13T20:10:38.000Z",
                "ctime": "2013-11-13T20:09:49.000Z",
                "mtime": "2013-11-13T20:09:49.000Z",
                "size": 170,
                "type": "directory"
              },
              "colors": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-11-13T20:09:49.000Z",
                  "size": 340,
                  "type": "directory"
                },
                "colors.js": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-08-21T23:13:23.000Z",
                    "size": 10646,
                    "type": "file"
                  },
                  "__ref": "23a08b63b337fc80259e39814c3304f5"
                },
                "example.js": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-08-21T21:21:02.000Z",
                    "size": 2423,
                    "type": "file"
                  },
                  "__ref": "d6a358179f5edaab86caf4d73a100b9a"
                },
                "package.json": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-11-13T20:09:49.000Z",
                    "size": 1984,
                    "type": "file"
                  },
                  "__ref": "0592598f044527569cea7ab205b82a49"
                },
                "test.js": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-08-21T21:31:17.000Z",
                    "size": 2138,
                    "type": "file"
                  },
                  "__ref": "f281098536a9e02598817e541e8e15a3"
                },
                "themes": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-11-13T20:09:49.000Z",
                    "size": 136,
                    "type": "directory"
                  },
                  "winston-dark.js": {
                    "__stat": {
                      "atime": "2013-11-13T20:10:38.000Z",
                      "ctime": "2013-11-13T20:09:49.000Z",
                      "mtime": "2013-07-26T05:36:07.000Z",
                      "size": 198,
                      "type": "file"
                    },
                    "__ref": "a5e50735f6652e9757ac1c7a63cf85ef"
                  },
                  "winston-light.js": {
                    "__stat": {
                      "atime": "2013-11-13T20:10:38.000Z",
                      "ctime": "2013-11-13T20:09:49.000Z",
                      "mtime": "2013-07-26T05:36:07.000Z",
                      "size": 197,
                      "type": "file"
                    },
                    "__ref": "8ae0394cb9f1165729513b6c35767b27"
                  }
                }
              }
            },
            "src": {
              "__stat": {
                "atime": "2013-11-13T20:10:38.000Z",
                "ctime": "2013-11-13T20:09:49.000Z",
                "mtime": "2013-11-13T20:09:49.000Z",
                "size": 238,
                "type": "directory"
              },
              "context.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-10-22T15:55:26.000Z",
                  "size": 4379,
                  "type": "file"
                },
                "__ref": "b9d463a910d4790add82d228e56200d0"
              },
              "minfinite.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-10-22T15:55:26.000Z",
                  "size": 1338,
                  "type": "file"
                },
                "__ref": "4aaff567286b962812b471b15e32f666"
              },
              "reporters.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-10-22T15:55:26.000Z",
                  "size": 7044,
                  "type": "file"
                },
                "__ref": "9b447f645747120b1ce9c0bf912d60e2"
              },
              "test.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-10-22T15:55:26.000Z",
                  "size": 2596,
                  "type": "file"
                },
                "__ref": "d9f643967b824a7805227d7fccafdc0e"
              },
              "testify.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-10-22T15:55:26.000Z",
                  "size": 817,
                  "type": "file"
                },
                "__ref": "fd4a31413497930ab9f29b0a7dfb92e6"
              }
            }
          },
          "patchboard-js": {
            "__stat": {
              "atime": "2013-11-13T20:10:38.000Z",
              "ctime": "2013-11-13T20:09:49.000Z",
              "mtime": "2013-11-13T20:09:49.000Z",
              "size": 204,
              "type": "directory"
            },
            "package.json": {
              "__stat": {
                "atime": "2013-11-13T20:10:38.000Z",
                "ctime": "2013-11-13T20:09:49.000Z",
                "mtime": "2013-11-13T20:09:49.000Z",
                "size": 1107,
                "type": "file"
              },
              "__ref": "a1f00f50ff4d060bfae75110bae95f21"
            },
            "node_modules": {
              "__stat": {
                "atime": "2013-11-13T20:10:38.000Z",
                "ctime": "2013-11-13T20:09:49.000Z",
                "mtime": "2013-11-13T20:09:49.000Z",
                "size": 136,
                "type": "directory"
              },
              "fairmont": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-11-13T20:09:49.000Z",
                  "size": 238,
                  "type": "directory"
                },
                "index.coffee": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-07-02T00:54:46.000Z",
                    "size": 3968,
                    "type": "file"
                  },
                  "__ref": "2bf3ec58ffdc0343a3db891c23d618e4"
                },
                "package.json": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-11-13T20:09:49.000Z",
                    "size": 4599,
                    "type": "file"
                  },
                  "__ref": "ae1e8a4286f3ce6a6aa02c606f340062"
                },
                "test.coffee": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-07-02T00:52:59.000Z",
                    "size": 1110,
                    "type": "file"
                  },
                  "__ref": "81951198ddb3737232107a27beaf8d5f"
                }
              },
              "jsck": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-11-13T20:09:49.000Z",
                  "size": 204,
                  "type": "directory"
                },
                "lib": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-11-13T20:09:49.000Z",
                    "size": 204,
                    "type": "directory"
                  },
                  "draft3": {
                    "__stat": {
                      "atime": "2013-11-13T20:10:38.000Z",
                      "ctime": "2013-11-13T20:09:49.000Z",
                      "mtime": "2013-11-13T20:09:49.000Z",
                      "size": 306,
                      "type": "directory"
                    },
                    "arrays.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-05T19:34:48.000Z",
                        "size": 2679,
                        "type": "file"
                      },
                      "__ref": "96d25db5f5df90904def9af7ec186d37"
                    },
                    "attributes.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-05T19:34:48.000Z",
                        "size": 873,
                        "type": "file"
                      },
                      "__ref": "bc5b865c7d167783d0dc7f60f7339e07"
                    },
                    "comparison.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-05T19:34:48.000Z",
                        "size": 1533,
                        "type": "file"
                      },
                      "__ref": "ee771fc350e250678e29eca4848122bf"
                    },
                    "numeric.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-05T19:34:48.000Z",
                        "size": 1338,
                        "type": "file"
                      },
                      "__ref": "e3d178a70062de42c511ad42d5183e16"
                    },
                    "objects.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-05T19:34:48.000Z",
                        "size": 5646,
                        "type": "file"
                      },
                      "__ref": "42f2a6591a00ad3978fe8498a25f6c38"
                    },
                    "strings.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-05T19:34:48.000Z",
                        "size": 4183,
                        "type": "file"
                      },
                      "__ref": "5318c531e976adfee8cf77dd9110fe2e"
                    },
                    "type.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-05T19:34:48.000Z",
                        "size": 2391,
                        "type": "file"
                      },
                      "__ref": "3477365edc59581475bbce22e45a815c"
                    }
                  },
                  "draft3.js": {
                    "__stat": {
                      "atime": "2013-11-13T20:10:38.000Z",
                      "ctime": "2013-11-13T20:09:49.000Z",
                      "mtime": "2013-11-05T19:34:48.000Z",
                      "size": 10291,
                      "type": "file"
                    },
                    "__ref": "253726bca0a9048c21b9d9d2b7bbc10d"
                  },
                  "index.js": {
                    "__stat": {
                      "atime": "2013-11-13T20:10:38.000Z",
                      "ctime": "2013-11-13T20:09:49.000Z",
                      "mtime": "2013-11-05T19:34:48.000Z",
                      "size": 87,
                      "type": "file"
                    },
                    "__ref": "3bb228a9f0315ca34fa56350046e7d89"
                  },
                  "uri.js": {
                    "__stat": {
                      "atime": "2013-11-13T20:10:38.000Z",
                      "ctime": "2013-11-13T20:09:49.000Z",
                      "mtime": "2013-11-05T19:34:48.000Z",
                      "size": 775,
                      "type": "file"
                    },
                    "__ref": "e04f7ebdcfb9b101cdeec3adcff8500c"
                  }
                },
                "node_modules": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-11-13T20:09:49.000Z",
                    "size": 102,
                    "type": "directory"
                  },
                  "deap": {
                    "__stat": {
                      "atime": "2013-11-13T20:10:38.000Z",
                      "ctime": "2013-11-13T20:09:50.000Z",
                      "mtime": "2013-11-13T20:09:50.000Z",
                      "size": 340,
                      "type": "directory"
                    },
                    "index.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-07-25T20:04:19.000Z",
                        "size": 274,
                        "type": "file"
                      },
                      "__ref": "1e4cb2365e86975cee5a5b62560522f1"
                    },
                    "lib": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-11-13T20:09:49.000Z",
                        "size": 136,
                        "type": "directory"
                      },
                      "deap.js": {
                        "__stat": {
                          "atime": "2013-11-13T20:10:38.000Z",
                          "ctime": "2013-11-13T20:09:49.000Z",
                          "mtime": "2013-07-25T20:04:19.000Z",
                          "size": 2177,
                          "type": "file"
                        },
                        "__ref": "07382efae33f8db8150060f66241f3a1"
                      },
                      "typeof.js": {
                        "__stat": {
                          "atime": "2013-11-13T20:10:38.000Z",
                          "ctime": "2013-11-13T20:09:50.000Z",
                          "mtime": "2013-05-07T00:50:02.000Z",
                          "size": 491,
                          "type": "file"
                        },
                        "__ref": "e06990ed80036013bdbc22008581eb04"
                      }
                    },
                    "package.json": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:50.000Z",
                        "mtime": "2013-11-13T20:09:50.000Z",
                        "size": 3861,
                        "type": "file"
                      },
                      "__ref": "31bd995c0bed879a71bdd8c87732813e"
                    },
                    "shallow.js": {
                      "__stat": {
                        "atime": "2013-11-13T20:10:38.000Z",
                        "ctime": "2013-11-13T20:09:49.000Z",
                        "mtime": "2013-07-25T20:04:19.000Z",
                        "size": 199,
                        "type": "file"
                      },
                      "__ref": "12938380d91199c2a4e563439e5d0bec"
                    }
                  }
                },
                "package.json": {
                  "__stat": {
                    "atime": "2013-11-13T20:10:38.000Z",
                    "ctime": "2013-11-13T20:09:49.000Z",
                    "mtime": "2013-11-13T20:09:49.000Z",
                    "size": 4555,
                    "type": "file"
                  },
                  "__ref": "69b3386a9d2baad0f210b3995381105f"
                }
              }
            },
            "src": {
              "__stat": {
                "atime": "2013-11-13T20:10:38.000Z",
                "ctime": "2013-11-13T20:09:49.000Z",
                "mtime": "2013-11-13T20:09:49.000Z",
                "size": 204,
                "type": "directory"
              },
              "action.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-11-13T19:15:51.000Z",
                  "size": 3113,
                  "type": "file"
                },
                "__ref": "18afc51605ce5367f79707f21337f219"
              },
              "client.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-11-13T19:18:53.000Z",
                  "size": 7745,
                  "type": "file"
                },
                "__ref": "6057cd0902b262138421abb292e2b8af"
              },
              "request.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-11-13T19:58:46.000Z",
                  "size": 3675,
                  "type": "file"
                },
                "__ref": "15c17f74b3a4728e12bc597d2db090fa"
              },
              "schema_manager.coffee": {
                "__stat": {
                  "atime": "2013-11-13T20:10:38.000Z",
                  "ctime": "2013-11-13T20:09:49.000Z",
                  "mtime": "2013-10-30T18:23:14.000Z",
                  "size": 634,
                  "type": "file"
                },
                "__ref": "b11267eae7cb3a8dd3670a00ed307031"
              }
            }
          }
        }
      },
      content: {
        "a9f52310ba86595371eb254be9bae277": "ewogICJuYW1lIjogInBhdGNoYm9hcmQtdHJpdmlhbC1icm93c2VyIiwKICAidmVyc2lvbiI6ICIwLjEuMCIsCiAgImRlc2NyaXB0aW9uIjogIkJyb3dzZXIgdGVzdCBmb3IgdHJpdmlhbCBQYXRjaGJvYXJkIGV4YW1wbGUiLAogICJtYWluIjogImFwcGxpY2F0aW9uLmNvZmZlZSIsCiAgInJlcG9zaXRvcnkiOiAiIiwKICAiYXV0aG9yIjogIk1hdHRoZXcgS2luZyIsCiAgImxpY2Vuc2UiOiAiTUlUIiwKICAiZGVwZW5kZW5jaWVzIjogewogICAgInRlc3RpZnkiOiAiMC4yLngiLAogICAgInBhdGNoYm9hcmQtanMiOiAiMC40LjByYzQiCiAgfQp9Cgo=",
        "191e63738fc82d8d97b4bc0ab16b2074": "MTkxZTYzNzM4ZmM4MmQ4ZDk3YjRiYzBhYjE2YjIwNzQ=",
        "3d78c3543db35b59635052552b1691e2": "ewogICJuYW1lIjogInRlc3RpZnkiLAogICJ2ZXJzaW9uIjogIjAuMi44IiwKICAiZGVzY3JpcHRpb24iOiAic2ltcGxlIGFzeW5jaHJvbm91cyB0ZXN0aW5nIHVzaW5nIGFzc2VydGlvbnMgb2YgeW91ciBjaG9pY2UiLAogICJtYWluIjogInNyYy90ZXN0aWZ5LmNvZmZlZSIsCiAgImJpbiI6IHsKICAgICJ0ZXN0aWZ5IjogImJpbi90ZXN0aWZ5IgogIH0sCiAgImZpbGVzIjogWwogICAgInNyYyIsCiAgICAiYmluLyIsCiAgICAiUkVBRE1FLm1kIgogIF0sCiAgImRlcGVuZGVuY2llcyI6IHsKICAgICJjb2ZmZWUtc2NyaXB0IjogIj49MC40LjAiLAogICAgImNvbG9ycyI6ICIwLjYueCIKICB9LAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiZ2l0QGdpdGh1Yi5jb206YXV0b21hdHRoZXcvdGVzdGlmeS5naXQiCiAgfSwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiTWF0dGhldyBLaW5nIiwKICAgICJlbWFpbCI6ICJhdXRvbWF0dGhld0BnbWFpbC5jb20iCiAgfSwKICAibGljZW5zZSI6ICJNSVQiLAogICJyZWFkbWUiOiAiIyBUZXN0aWZ5XG5cblNpbXBsZSBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIHRlc3RpbmcsIHVzaW5nIHRoZSBhc3NlcnRpb25zIG9mIHlvdXIgY2hvaWNlLlxuXG5Xcml0dGVuIChhbmQgbW9zdCBlYXNpbHkgdXNlZCkgaW4gQ29mZmVlU2NyaXB0LlxuXG4jIyBCYXNpYyB1c2FnZVxuXG5gYGAuY29mZmVlXG5cblRlc3RpZnkgPSByZXF1aXJlIFwiLi4vc3JjL3Rlc3RpZnlcIlxuYXNzZXJ0ID0gcmVxdWlyZSBcImFzc2VydFwiXG5cblRlc3RpZnkudGVzdCBcInN0cmFpZ2h0Zm9yd2FyZCBzeW5jaHJvbm91cyB0ZXN0aW5nXCIsIChjb250ZXh0KSAtPlxuXG4gIGNvbnRleHQudGVzdCBcImFyaXRobWV0aWNcIiwgLT5cbiAgICBhc3NlcnQuZXF1YWwgKDIgKyAyKSwgNFxuXG4gIGNvbnRleHQudGVzdCBcInN0cmluZ3NcIiwgLT5cbiAgICBhc3NlcnQuZXF1YWwgXCJmb29cIi50b1VwcGVyQ2FzZSgpLCBcIkZPT1wiXG5cbiAgY29udGV4dC50ZXN0IFwiZXJyb3IgaGFuZGxpbmdcIiwgLT5cbiAgICBlcnJvciA9IG5ldyBFcnJvciBcIkkgZmFpbGVkLlwiXG4gICAgYXNzZXJ0LmlmRXJyb3IoZXJyb3IpXG5cbmBgYFxuXG5PdXRwdXQ6XG5cbiFbYmFzaWMgdXNhZ2Ugb3V0cHV0XShodHRwczovL3Jhdy5naXRodWIuY29tL2F1dG9tYXR0aGV3L3Rlc3RpZnkvZG9jdW1lbnRhdGlvbi9kb2MvYmFzaWNfdXNhZ2UucG5nKVxuXG5cbiMjIEFzeW5jaHJvbm91cyB1c2FnZVxuXG5gYGAuY29mZmVlXG5cbnNvbWVfYXN5bmNfY2FsbCA9IChjYWxsYmFjaykgLT5cbiAgcHJvY2Vzcy5uZXh0VGljayAtPlxuICAgIGNhbGxiYWNrIG51bGwsIFwicGllXCJcblxuYW5vdGhlcl9hc3luY19jYWxsID0gKGlucHV0LCBjYWxsYmFjaykgLT5cbiAgcHJvY2Vzcy5uZXh0VGljayAtPlxuICAgIGNhbGxiYWNrIG51bGwsIFtcImJhY29uXCIsIFwiY2hlZXNlXCIsIFwicGllXCJdXG5cblRlc3RpZnkudGVzdCBcImEgc3VpdGUgb2YgdGVzdHNcIiwgKGNvbnRleHQpIC0+XG5cbiAgIyBXaGVuIHlvdSBuZWVkIHRvIHRlc3QgdGhlIHJlc3VsdHMgb2YgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLFxuICAjIGdpdmUgY29udGV4dC50ZXN0KCkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFyZ3VtZW50LiAgWW91IGNhblxuICAjIHRoZW4gdXNlIHRoYXQgYXJndW1lbnQgYXMgYSBuZXcgY29udGV4dCBmb3IgbmVzdGluZyB0ZXN0cy5cbiAgY29udGV4dC50ZXN0IFwidGVzdGluZyBzb21ldGhpbmcgYXN5bmNocm9ub3VzXCIsIChjb250ZXh0KSAtPlxuXG4gICAgc29tZV9hc3luY19jYWxsIChlcnJvciwgcmVzdWx0MSkgLT5cblxuICAgICAgIyBJZiB5b3UgZ2l2ZSBjb250ZXh0LnRlc3QoKSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzLFxuICAgICAgIyB0aGUgdGVzdCBpcyByZXF1aXJlZCB0byBiZSBzeW5jaHJvbm91cywgYW5kIGNvbnNpZGVyZWQgdG8gaGF2ZVxuICAgICAgIyBwYXNzZWQgaWYgdGhlIGZ1bmN0aW9uIHJ1bnMgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgIGNvbnRleHQudGVzdCBcInJlc3VsdCBtYWtlcyBtZSBoYXBweVwiLCAtPlxuICAgICAgICBhc3NlcnQuaWZFcnJvcihlcnJvcilcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdDEsIFwicGllXCIpXG5cbiAgICAgIGNvbnRleHQudGVzdCBcImEgbmVzdGVkIGFzeW5jaHJvbm91cyB0ZXN0XCIsIChjb250ZXh0KSAtPlxuXG4gICAgICAgIGFub3RoZXJfYXN5bmNfY2FsbCByZXN1bHQxLCAgKGVycm9yLCByZXN1bHQyKSAtPlxuXG4gICAgICAgICAgY29udGV4dC50ZXN0IFwicmVzdWx0IG1ha2VzIG1lIGRlZXBseSBoYXBweVwiLCAtPlxuICAgICAgICAgICAgYXNzZXJ0LmlmRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsIHJlc3VsdDIsIFtcImJhY29uXCIsIFwiY2hlZXNlXCIsIFwicGllXCJdXG5cbiAgICAgIGNvbnRleHQudGVzdCBcInNob3J0Y3V0IGZvciBwYXNzaW5nIGFuIGFzeW5jIHRlc3RcIiwgKGNvbnRleHQpIC0+XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sgLT5cbiAgICAgICAgICAjIHlvdSBjYW4gY2FsbCBjb250ZXh0LnBhc3MoKSBpbnN0ZWFkIG9mIHVzaW5nIGEgc3luY2hyb25vdXMgdGVzdFxuICAgICAgICAgIGNvbnRleHQucGFzcygpXG5cbiAgICAgIGNvbnRleHQudGVzdCBcInNob3J0Y3V0IGZvciBmYWlsaW5nIGFuIGFzeW5jIHRlc3RcIiwgKGNvbnRleHQpIC0+XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sgLT5cbiAgICAgICAgICBjb250ZXh0LmZhaWwoXCJJIGp1c3QgY291bGRuJ3QgZ28gb25cIilcblxuYGBgXG5cbk91dHB1dDpcblxuIVthc3luYyB1c2FnZSBvdXRwdXRdKGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vYXV0b21hdHRoZXcvdGVzdGlmeS9kb2N1bWVudGF0aW9uL2RvYy9hc3luY191c2FnZS5wbmcpXG5cblJ1biB5b3VyIHRlc3QgZmlsZXMgd2l0aCB0aGUgYGNvZmZlZWAgZXhlY3V0YWJsZSwgb3IgYnkgcmVxdWlyaW5nIHRoZW0sIG9yIHVzaW5nIGBiaW4vdGVzdGlmeSBbLS1jb2xvcl1gLlxuXG4gICAgY29mZmVlIHBhdGgvdG8vdGVzdC5jb2ZmZWVcbiAgICBiaW4vdGVzdGlmeSAtYyBwYXRoL3RvL3Rlc3QuY29mZmVlXG5cbiMjIEV4YW1wbGVzXG5cbltUZXN0cyBmb3IgU2hyZWQsIGFuIEhUVFAgY2xpZW50XShodHRwczovL2dpdGh1Yi5jb20vYXV0b21hdHRoZXcvc2hyZWQvYmxvYi9tYXN0ZXIvdGVzdC9zaHJlZF90ZXN0LmNvZmZlZSlcblxuWW91IGNhbiBhbHNvIHVzZSB0ZXN0IG5lc3Rpbmcgd2l0aCBlbnRpcmVseSBzeW5jaHJvbm91cyB3b3JrLCBhcyBhIHdheSB0byBzdHJ1Y3R1cmUgdGhlXG50ZXN0IHJlc3VsdHM6XG5cbltTaHJlZCdzIGhlYWRlciBwcm9jZXNzaW5nIHRlc3RdKGh0dHBzOi8vZ2l0aHViLmNvbS9hdXRvbWF0dGhldy9zaHJlZC9ibG9iL21hc3Rlci90ZXN0L2hlYWRlcnNfdGVzdC5jb2ZmZWUpXG5cblxuXG5cbiIsCiAgInJlYWRtZUZpbGVuYW1lIjogIlJFQURNRS5tZCIsCiAgImJ1Z3MiOiB7CiAgICAidXJsIjogImh0dHBzOi8vZ2l0aHViLmNvbS9hdXRvbWF0dGhldy90ZXN0aWZ5L2lzc3VlcyIKICB9LAogICJfaWQiOiAidGVzdGlmeUAwLjIuOCIsCiAgIl9mcm9tIjogInRlc3RpZnlAMC4yLngiCn0K",
        "23a08b63b337fc80259e39814c3304f5": "MjNhMDhiNjNiMzM3ZmM4MDI1OWUzOTgxNGMzMzA0ZjU=",
        "d6a358179f5edaab86caf4d73a100b9a": "ZDZhMzU4MTc5ZjVlZGFhYjg2Y2FmNGQ3M2ExMDBiOWE=",
        "0592598f044527569cea7ab205b82a49": "ewogICJuYW1lIjogImNvbG9ycyIsCiAgImRlc2NyaXB0aW9uIjogImdldCBjb2xvcnMgaW4geW91ciBub2RlLmpzIGNvbnNvbGUgbGlrZSB3aGF0IiwKICAidmVyc2lvbiI6ICIwLjYuMiIsCiAgImF1dGhvciI6IHsKICAgICJuYW1lIjogIk1hcmFrIFNxdWlyZXMiCiAgfSwKICAiaG9tZXBhZ2UiOiAiaHR0cHM6Ly9naXRodWIuY29tL01hcmFrL2NvbG9ycy5qcyIsCiAgImJ1Z3MiOiB7CiAgICAidXJsIjogImh0dHBzOi8vZ2l0aHViLmNvbS9NYXJhay9jb2xvcnMuanMvaXNzdWVzIgogIH0sCiAgImtleXdvcmRzIjogWwogICAgImFuc2kiLAogICAgInRlcm1pbmFsIiwKICAgICJjb2xvcnMiCiAgXSwKICAicmVwb3NpdG9yeSI6IHsKICAgICJ0eXBlIjogImdpdCIsCiAgICAidXJsIjogImh0dHA6Ly9naXRodWIuY29tL01hcmFrL2NvbG9ycy5qcy5naXQiCiAgfSwKICAiZW5naW5lcyI6IHsKICAgICJub2RlIjogIj49MC4xLjkwIgogIH0sCiAgIm1haW4iOiAiY29sb3JzIiwKICAicmVhZG1lIjogIiMgY29sb3JzLmpzIC0gZ2V0IGNvbG9yIGFuZCBzdHlsZSBpbiB5b3VyIG5vZGUuanMgY29uc29sZSAoIGFuZCBicm93c2VyICkgbGlrZSB3aGF0XG5cbjxpbWcgc3JjPVwiaHR0cDovL2kuaW1ndXIuY29tL2dvSmRPLnBuZ1wiIGJvcmRlciA9IFwiMFwiLz5cblxuXG4jIyBJbnN0YWxsYXRpb25cblxuICAgIG5wbSBpbnN0YWxsIGNvbG9yc1xuXG4jIyBjb2xvcnMgYW5kIHN0eWxlcyFcblxuLSBib2xkXG4tIGl0YWxpY1xuLSB1bmRlcmxpbmVcbi0gaW52ZXJzZVxuLSB5ZWxsb3dcbi0gY3lhblxuLSB3aGl0ZVxuLSBtYWdlbnRhXG4tIGdyZWVuXG4tIHJlZFxuLSBncmV5XG4tIGJsdWVcbi0gcmFpbmJvd1xuLSB6ZWJyYVxuLSByYW5kb21cblxuIyMgVXNhZ2VcblxuYGBgIGpzXG52YXIgY29sb3JzID0gcmVxdWlyZSgnLi9jb2xvcnMnKTtcblxuY29uc29sZS5sb2coJ2hlbGxvJy5ncmVlbik7IC8vIG91dHB1dHMgZ3JlZW4gdGV4dFxuY29uc29sZS5sb2coJ2kgbGlrZSBjYWtlIGFuZCBwaWVzJy51bmRlcmxpbmUucmVkKSAvLyBvdXRwdXRzIHJlZCB1bmRlcmxpbmVkIHRleHRcbmNvbnNvbGUubG9nKCdpbnZlcnNlIHRoZSBjb2xvcicuaW52ZXJzZSk7IC8vIGludmVyc2VzIHRoZSBjb2xvclxuY29uc29sZS5sb2coJ09NRyBSYWluYm93cyEnLnJhaW5ib3cpOyAvLyByYWluYm93IChpZ25vcmVzIHNwYWNlcylcbmBgYFxuXG4jIENyZWF0aW5nIEN1c3RvbSB0aGVtZXNcblxuYGBganNcblxudmFyIGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycycpO1xuXG5jb2xvcnMuc2V0VGhlbWUoe1xuICBzaWxseTogJ3JhaW5ib3cnLFxuICBpbnB1dDogJ2dyZXknLFxuICB2ZXJib3NlOiAnY3lhbicsXG4gIHByb21wdDogJ2dyZXknLFxuICBpbmZvOiAnZ3JlZW4nLFxuICBkYXRhOiAnZ3JleScsXG4gIGhlbHA6ICdjeWFuJyxcbiAgd2FybjogJ3llbGxvdycsXG4gIGRlYnVnOiAnYmx1ZScsXG4gIGVycm9yOiAncmVkJ1xufSk7XG5cbi8vIG91dHB1dHMgcmVkIHRleHRcbmNvbnNvbGUubG9nKFwidGhpcyBpcyBhbiBlcnJvclwiLmVycm9yKTtcblxuLy8gb3V0cHV0cyB5ZWxsb3cgdGV4dFxuY29uc29sZS5sb2coXCJ0aGlzIGlzIGEgd2FybmluZ1wiLndhcm4pO1xuYGBgXG5cblxuIyMjIENvbnRyaWJ1dG9ycyBcblxuTWFyYWsgKE1hcmFrIFNxdWlyZXMpXG5BbGV4aXMgU2VsbGllciAoY2xvdWRoZWFkKVxubW1hbGVja2kgKE1hY2llaiBNYcWCZWNraSlcbm5pY29yZWVkIChOaWNvIFJlZWQpXG5tb3JnYW5yYWxsZW4gKE1vcmdhbiBBbGxlbilcbkp1c3RpbkNhbXBiZWxsIChKdXN0aW4gQ2FtcGJlbGwpXG5kZWQgKER1c3RpbiBEaWF6KVxuXG5cbiMjIyMgICwgTWFyYWsgU3F1aXJlcyAsIEp1c3RpbiBDYW1wYmVsbCwgRHVzdGluIERpYXogKEBkZWQpXG4iLAogICJyZWFkbWVGaWxlbmFtZSI6ICJSZWFkTWUubWQiLAogICJfaWQiOiAiY29sb3JzQDAuNi4yIiwKICAiX2Zyb20iOiAiY29sb3JzQDAuNi54Igp9Cg==",
        "f281098536a9e02598817e541e8e15a3": "ZjI4MTA5ODUzNmE5ZTAyNTk4ODE3ZTU0MWU4ZTE1YTM=",
        "a5e50735f6652e9757ac1c7a63cf85ef": "YTVlNTA3MzVmNjY1MmU5NzU3YWMxYzdhNjNjZjg1ZWY=",
        "8ae0394cb9f1165729513b6c35767b27": "OGFlMDM5NGNiOWYxMTY1NzI5NTEzYjZjMzU3NjdiMjc=",
        "b9d463a910d4790add82d228e56200d0": "YjlkNDYzYTkxMGQ0NzkwYWRkODJkMjI4ZTU2MjAwZDA=",
        "4aaff567286b962812b471b15e32f666": "NGFhZmY1NjcyODZiOTYyODEyYjQ3MWIxNWUzMmY2NjY=",
        "9b447f645747120b1ce9c0bf912d60e2": "OWI0NDdmNjQ1NzQ3MTIwYjFjZTljMGJmOTEyZDYwZTI=",
        "d9f643967b824a7805227d7fccafdc0e": "ZDlmNjQzOTY3YjgyNGE3ODA1MjI3ZDdmY2NhZmRjMGU=",
        "fd4a31413497930ab9f29b0a7dfb92e6": "ZmQ0YTMxNDEzNDk3OTMwYWI5ZjI5YjBhN2RmYjkyZTY=",
        "a1f00f50ff4d060bfae75110bae95f21": "ewogICJuYW1lIjogInBhdGNoYm9hcmQtanMiLAogICJkZXNjcmlwdGlvbiI6ICJKYXZhU2NyaXB0IGNsaWVudCBmb3IgUGF0Y2hib2FyZCBBUElzIiwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiTWF0dGhldyBLaW5nIgogIH0sCiAgInZlcnNpb24iOiAiMC40LjByYzQiLAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiZ2l0Oi8vZ2l0aHViLmNvbS9hdXRvbWF0dGhldy9wYXRjaGJvYXJkLWpzLmdpdCIKICB9LAogICJtYWluIjogIi4vc3JjL2NsaWVudC5jb2ZmZWUiLAogICJmaWxlcyI6IFsKICAgICJzcmMvIgogIF0sCiAgImRlcGVuZGVuY2llcyI6IHsKICAgICJqc2NrIjogIjAuMS4zIiwKICAgICJmYWlybW9udCI6ICJ+MC43LjAiCiAgfSwKICAiZGV2RGVwZW5kZW5jaWVzIjogewogICAgInRlc3RpZnkiOiAiMC4yLngiLAogICAgImRlYXAiOiAifjAuMi4wIgogIH0sCiAgInJlYWRtZSI6ICIjIFBhdGNoYm9hcmQgQ2xpZW50IGZvciBKYXZhU2NyaXB0XG5cbiMjIFVzYWdlXG5cblxuYGBgY29mZmVlXG5DbGllbnQgPSByZXF1aXJlIFwicGF0Y2hib2FyZC1qc1wiXG5cbiMgR2l2ZSBDbGllbnQuZGlzY292ZXIgdGhlIFVSTCB0byBhIFBhdGNoYm9hcmQgQVBJIHNlcnZlclxuQ2xpZW50LmRpc2NvdmVyIFwiaHR0cDovL2FwaS53aGVyZXZlci5jb20vXCIsIChjbGllbnQpIC0+XG4gIHt1c2Vyc30gPSBjbGllbnQucmVzb3VyY2VzXG4gIHVzZXJzLmNyZWF0ZSB7bG9naW46IFwibWF0dGhld1wifSwgKGVycm9yLCByZXNwb25zZSkgLT5cbiAgICBpZiBlcnJvclxuICAgICAgY29uc29sZS5lcnJvciBlcnJvclxuICAgIGVsc2VcbiAgICAgIHVzZXIudXBkYXRlIHtlbWFpbDogXCJtYXR0aGV3QG1haWwuY29tfSwgKGVycm9yLCByZXNwb25zZSkgLT5cblxuYGBgXG5cbiIsCiAgInJlYWRtZUZpbGVuYW1lIjogIlJFQURNRS5tZCIsCiAgImJ1Z3MiOiB7CiAgICAidXJsIjogImh0dHBzOi8vZ2l0aHViLmNvbS9hdXRvbWF0dGhldy9wYXRjaGJvYXJkLWpzL2lzc3VlcyIKICB9LAogICJfaWQiOiAicGF0Y2hib2FyZC1qc0AwLjQuMHJjNCIsCiAgIl9mcm9tIjogInBhdGNoYm9hcmQtanNAMC40LjByYzQiCn0K",
        "2bf3ec58ffdc0343a3db891c23d618e4": "MmJmM2VjNThmZmRjMDM0M2EzZGI4OTFjMjNkNjE4ZTQ=",
        "ae1e8a4286f3ce6a6aa02c606f340062": "ewogICJuYW1lIjogImZhaXJtb250IiwKICAidmVyc2lvbiI6ICIwLjcuMCIsCiAgImRlc2NyaXB0aW9uIjogIkEgY29sbGVjdGlvbiBvZiB1c2VmdWwgZnVuY3Rpb25zIGFuZCB1dGlsaXRpZXMuIiwKICAibWFpbiI6ICJpbmRleC5jb2ZmZWUiLAogICJzY3JpcHRzIjogewogICAgInRlc3QiOiAiZWNobyBcIkVycm9yOiBubyB0ZXN0IHNwZWNpZmllZFwiICYmIGV4aXQgMSIKICB9LAogICJyZXBvc2l0b3J5IjogewogICAgInR5cGUiOiAiZ2l0IiwKICAgICJ1cmwiOiAiZ2l0Oi8vZ2l0aHViLmNvbS9keW9kZXIvZmFpcm1vbnQuZ2l0IgogIH0sCiAgImtleXdvcmRzIjogWwogICAgImNvZmZlZSIsCiAgICAiY29mZmVlc2NyaXB0IiwKICAgICJ1dGlsaXR5IgogIF0sCiAgImF1dGhvciI6IHsKICAgICJuYW1lIjogIkRhbiBZb2RlciIKICB9LAogICJsaWNlbnNlIjogIkJTRCIsCiAgImRldkRlcGVuZGVuY2llcyI6IHsKICAgICJ0ZXN0aWZ5IjogIn4wLjIuNCIKICB9LAogICJyZWFkbWUiOiAiIyBGYWlybW9udFxuXG5BIGNvbGxlY3Rpb24gb2YgdXNlZnVsIENvZmZlZVNjcmlwdC9KYXZhU2NyaXB0IGZ1bmN0aW9ucy5cblxuIyMgR2VuZXJhbCBQdXJwb3NlIEZ1bmN0aW9uc1xuXG4qKncqKiBTcGxpdCBhIHN0cmluZyBvbiB3aGl0ZXNwYWNlLiBVc2VmdWwgZm9yIGNvbmNpc2VseSBjcmVhdGluZyBhcnJheXMgb2Ygc3RyaW5ncy5cblxuICAgIGNvbnNvbGUubG9nIHdvcmQgZm9yIHdvcmQgaW4gdyBcImZvbyBiYXIgYmF6XCJcbiAgICBcbioqdHlwZSoqIEdldCB0aGUgdHlwZSBvZiBhIHZhbHVlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgbnVtYmVyYCwgYHN0cmluZ2AsICdgYm9vbGVhbmAsIGBkYXRhYCwgYHJlZ2V4cGAsIGBmdW5jdGlvbmAsIGBhcnJheWAsIGBvYmplY3RgLCBgbnVsbGAsIGB1bmRlZmluZWRgLiBBZGFwdGVkIGZyb20gW1RoZSBDb2ZmZWVTY3JpcHQgQ29va2Jvb2tdWzBdIGFuZCBiYXNlZCBvbiBEb3VnbGFzIENyb2NrZm9yZCdzIFtyZW1lZGlhbCBKYXZhU2NyaXB0IGJsb2cgcG9zdF1bMV0uXG5cblswXTpodHRwOi8vY29mZmVlc2NyaXB0Y29va2Jvb2suY29tL2NoYXB0ZXJzL2NsYXNzZXNfYW5kX29iamVjdHMvdHlwZS1mdW5jdGlvblxuWzFdOmh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vcmVtZWRpYWwuaHRtbFxuXG4gICAgZm9vKCkgaWYgdHlwZSggZm9vICkgPT0gXCJmdW5jdGlvblwiXG5cbioqdGltZXIqKiBTZXQgYSB0aW1lci4gVGFrZXMgYW4gaW50ZXJ2YWwgaW4gbWljcm9zZWNvbmRzIGFuZCBhbiBhY3Rpb24uIFJldHVybnMgYSBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHRpbWVyLiBCYXNpY2FsbHksIGEgbW9yZSBjb252ZW5pZW50IHdheSB0byBjYWxsIGBzZXRUaW1lb3V0YCBhbmQgYGNsZWFyVGltZW91dGAuXG5cbiAgICBjYW5jZWwgPSB0aW1lciAxMDAwLCAtPiBjb25zb2xlLmxvZyBcIkRvbmVcIlxuICAgIGNhbmNlbCgpXG4gICAgXG4jIyBBcnJheSBGdW5jdGlvbnNcblxuKipyZW1vdmUqKiBEZXN0cnVjdGl2ZWx5IHJlbW92ZSBhbiBlbGVtZW50IGZyb20gYW4gYXJyYXkuIFJldHVybnMgdGhlIGVsZW1lbnQgcmVtb3ZlZC5cblxuICAgIGEgPSB3IFwiZm9vIGJhciBiYXpcIlxuICAgIHJlbW92ZSggYSwgXCJiYXJcIiApXG5cbioqdW5pcSoqIFRha2VzIGFuIGFycmF5IGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggYWxsIGR1cGxpY2F0ZSB2YWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgYXJyYXkgcmVtb3ZlZC4gQWxzbyB0YWtlcyBhbiBvcHRpb25hbCBoYXNoIGZ1bmN0aW9uIHRoYXQgZGVmYXVsdHMgdG8gY2FsbGluZyBgdG9TdHJpbmdgIG9uIHRoZSBlbGVtZW50cy4gXG5cbiAgICB1bmlxIFsxLDIsMywxLDIsMyw0LDUsNiwzLDYsMiw0XVxuICAgICMgcmV0dXJucyBbMSwyLDMsNCw1LDZdXG4gICAgXG4jIyBGaWxlIFN5c3RlbSBGdW5jdGlvbnNcblxuQWxsIGZpbGUtc3lzdGVtIGZ1bmN0aW9ucyBhcmUgYmFzZWQgb24gTm9kZSdzIGBmc2AgQVBJLiBUaGlzIGlzIG5vdCBgcmVxdWlyZWBkIHVubGVzcyB0aGUgZnVuY3Rpb24gaXMgYWN0dWFsbHkgaW52b2tlZC5cblxuKipleGlzdHMqKiBDaGVjayB0byBzZWUgaWYgYSBmaWxlIGV4aXN0cy5cblxuICAgIHNvdXJjZSA9IHJlYWQoIHNvdXJjZVBhdGggKSBpZiBleGlzdHMoIHNvdXJjZVBhdGggKVxuXG4qKnJlYWQqKiBSZWFkIGEgZmlsZSBzeW5jaHJvbm91c2x5IGFuZCByZXR1cm4gYSBVVEYtOCBzdHJpbmcgb2YgdGhlIGNvbnRlbnRzLlxuXG4gICAgc291cmNlID0gcmVhZCggc291cmNlUGF0aCApIGlmIGV4aXN0cyggc291cmNlUGF0aCApXG5cbioqd3JpdGUqKiBTeW5jaHJvbm91c2x5IHdyaXRlIGEgVVRGLTggc3RyaW5nIHRvIGEgZmlsZS5cblxuICAgIHdyaXRlKCBmaWxlLnJlcGxhY2UoIC9mb28vZywgJ2JhcicgKSApXG5cbioqcmVhZGRpcioqIFN5bmNocm9ub3VzbHkgZ2V0IHRoZSBjb250ZW50cyBvZiBhIGRpcmVjdG9yeSBhcyBhbiBhcnJheS5cblxuICAgIGZvciBmaWxlIGluIHJlYWRkaXIoXCJkb2N1bWVudHNcIilcbiAgICAgIGNvbnNvbGUubG9nIHJlYWQoIGZpbGUgKSBpZiBzdGF0KCBmaWxlICkuaXNGaWxlKClcblxuKipzdGF0KiogU3luY2hyb25vdXNseSBnZXQgdGhlIHN0YXQgb2JqZWN0IGZvciBhIGZpbGUuXG5cbiAgICBmb3IgZmlsZSBpbiByZWFkZGlyKFwiZG9jdW1lbnRzXCIpXG4gICAgICBjb25zb2xlLmxvZyByZWFkKCBmaWxlICkgaWYgc3RhdCggZmlsZSApLmlzRmlsZSgpXG5cbioqY2hkaXIqKiBDaGFuZ2UgZGlyZWN0b3JpZXMsIGV4ZWN1dGUgYSBmdW5jdGlvbiwgYW5kIHRoZW4gcmVzdG9yZSB0aGUgb3JpZ2luYWwgd29ya2luZyBkaXJlY3RvcnkuXG5cbiAgICBjaGRpciBcImRvY3VtZW50c1wiLCAtPlxuICAgICAgY29uc29sZS5sb2cgcmVhZCggXCJSRUFETUVcIiApXG4gICAgICBcbioqcm0qKiBSZW1vdmVzIGEgZmlsZS5cblxuICAgIHJtIFwiZG9jdW1lbnRzL3JlYW1kZS50eHRcIlxuXG4qKnJtZGlyKiogUmVtb3ZlcyBhIGRpcmVjdG9yeS5cblxuICAgIHJtZGlyIFwiZG9jdW1lbnRzXCJcblxuIyMgSGFzaGluZy9FbmNvZGluZyBGdW5jdGlvbnNcblxuKiptZDUqKiBSZXR1cm4gdGhlIE1ENSBoYXNoIG9mIGEgc3RyaW5nLlxuXG4gICAgbnV0c2hlbGwgPSBtZDUoIG15TGlmZVN0b3J5IClcblxuKipiYXNlNjQqKiBCYXNlNjQgZW5jb2RlIGEgc3RyaW5nLiAoTm90IFVSTCBzYWZlLilcblxuICAgIGltYWdlID0gZGF0YTogYmFzZTY0KCBpbWFnZURhdGEgKVxuXG4jIyBPYmplY3QgRnVuY3Rpb25zXG5cbioqaW5jbHVkZSoqIEFkZHMgdGhlIHByb3BlcnRpZXMgb2Ygb25lIG9yIG1vcmUgb2JqZWN0cyB0byBhbm90aGVyLlxuXG4gICAgaW5jbHVkZSggQCwgU2Nyb2xsYmFyTWl4aW4sIFNpZGViYXJNaXhpbiApXG5cbioqbWVyZ2UqKiBDcmVhdGVzIG5ldyBvYmplY3QgYnkgcHJvZ3Jlc3NpdmVseSBhZGRpbmcgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBnaXZlbiBvYmplY3QuXG5cbiAgICBvcHRpb25zID0gbWVyZ2UoIGRlZmF1bHRzLCBnbG9iYWxPcHRpb25zLCBsb2NhbE9wdGlvbnMgKVxuXG4qKmRlbGVnYXRlKiogRGVsZWdhdGVzIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyIGJ5IGNyZWF0aW5nIGZ1bmN0aW9ucyBpbiB0aGUgZmlyc3Qgb2JqZWN0IHRoYXQgY2FsbCB0aGUgc2Vjb25kLlxuXG4gICAgZGVsZWdhdGUoIGFQcm94eSwgYVNlcnZlciApXG5cbiMjIE9iamVjdCBNaXhpbnNcblxuTWl4aW5zIGFyZSBvYmplY3RzIHRoYXQgeW91IGNhbiBgaW5jbHVkZWAgaW50byBhbm90aGVyLCB0eXBpY2FsbHkgYWRkaW5nIGZlYXR1cmVzIHRvIGFuIG9iamVjdCBpbiB0aGUgcHJvY2Vzcy5cblxuKipQcm9wZXJ0eSoqIEFkZCBhIGBwcm9wZXJ0eWAgbWV0aG9kIHRvIGEgY2xhc3MsIG1ha2luZyBpdCBlYXNpZXIgdG8gZGVmaW5lIGdldHRlcnMgYW5kIHNldHRlcnMgb24gaXRzIHByb3RvdHlwZS5cblxuICAgIGNsYXNzIEZvb1xuICAgICAgaW5jbHVkZSBALCBQcm9wZXJ0eVxuICAgICAgcHJvcGVydHkgXCJmb29cIiwgZ2V0OiAtPiBAX2Zvbywgc2V0OiAodikgLT4gQF9mb28gPSB2XG5cblByb3BlcnRpZXMgZGVmaW5lZCB1c2luZyBgcHJvcGVydHlgIGFyZSBlbnVtZXJhYmxlLlxuXG4jIyBGdW5jdGlvbiBGdW5jdGlvbnNcblxuKiptZW1vaXplKiogQSB2ZXJ5IHNpbXBsZSB3YXkgdG8gY2FjaGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgdGhhdCB0YWtlIGEgc2luZ2xlIGFyZ3VtZW50LiBBbHNvIHRha2VzIGFuIG9wdGlvbmFsIGhhc2ggZnVuY3Rpb24gdGhhdCBkZWZhdWx0cyB0byBjYWxsaW5nIGB0b1N0cmluZ2Agb24gdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnQuXG5cbiAgICBuaWNrbmFtZSA9IChlbWFpbCkgLT5cbiAgICAgIGV4cGVuc2l2ZUxvb2t1cFRvR2V0Tmlja25hbWUoIGVtYWlsIClcbiAgICAgIFxuICAgIG1lbW9pemUoIG5pY2tuYW1lICkiLAogICJyZWFkbWVGaWxlbmFtZSI6ICJSRUFETUUubWQiLAogICJidWdzIjogewogICAgInVybCI6ICJodHRwczovL2dpdGh1Yi5jb20vZHlvZGVyL2ZhaXJtb250L2lzc3VlcyIKICB9LAogICJfaWQiOiAiZmFpcm1vbnRAMC43LjAiLAogICJfZnJvbSI6ICJmYWlybW9udEB+MC43LjAiCn0K",
        "81951198ddb3737232107a27beaf8d5f": "ODE5NTExOThkZGIzNzM3MjMyMTA3YTI3YmVhZjhkNWY=",
        "96d25db5f5df90904def9af7ec186d37": "OTZkMjVkYjVmNWRmOTA5MDRkZWY5YWY3ZWMxODZkMzc=",
        "bc5b865c7d167783d0dc7f60f7339e07": "YmM1Yjg2NWM3ZDE2Nzc4M2QwZGM3ZjYwZjczMzllMDc=",
        "ee771fc350e250678e29eca4848122bf": "ZWU3NzFmYzM1MGUyNTA2NzhlMjllY2E0ODQ4MTIyYmY=",
        "e3d178a70062de42c511ad42d5183e16": "ZTNkMTc4YTcwMDYyZGU0MmM1MTFhZDQyZDUxODNlMTY=",
        "42f2a6591a00ad3978fe8498a25f6c38": "NDJmMmE2NTkxYTAwYWQzOTc4ZmU4NDk4YTI1ZjZjMzg=",
        "5318c531e976adfee8cf77dd9110fe2e": "NTMxOGM1MzFlOTc2YWRmZWU4Y2Y3N2RkOTExMGZlMmU=",
        "3477365edc59581475bbce22e45a815c": "MzQ3NzM2NWVkYzU5NTgxNDc1YmJjZTIyZTQ1YTgxNWM=",
        "253726bca0a9048c21b9d9d2b7bbc10d": "MjUzNzI2YmNhMGE5MDQ4YzIxYjlkOWQyYjdiYmMxMGQ=",
        "3bb228a9f0315ca34fa56350046e7d89": "M2JiMjI4YTlmMDMxNWNhMzRmYTU2MzUwMDQ2ZTdkODk=",
        "e04f7ebdcfb9b101cdeec3adcff8500c": "ZTA0ZjdlYmRjZmI5YjEwMWNkZWVjM2FkY2ZmODUwMGM=",
        "1e4cb2365e86975cee5a5b62560522f1": "MWU0Y2IyMzY1ZTg2OTc1Y2VlNWE1YjYyNTYwNTIyZjE=",
        "07382efae33f8db8150060f66241f3a1": "MDczODJlZmFlMzNmOGRiODE1MDA2MGY2NjI0MWYzYTE=",
        "e06990ed80036013bdbc22008581eb04": "ZTA2OTkwZWQ4MDAzNjAxM2JkYmMyMjAwODU4MWViMDQ=",
        "31bd995c0bed879a71bdd8c87732813e": "ewogICJuYW1lIjogImRlYXAiLAogICJ2ZXJzaW9uIjogIjAuMi4wIiwKICAiZGVzY3JpcHRpb24iOiAiZXh0ZW5kIGFuZCBtZXJnZSBvYmplY3RzLCBkZWVwIG9yIHNoYWxsb3ciLAogICJtYWluIjogImluZGV4LmpzIiwKICAic2NyaXB0cyI6IHsKICAgICJ0ZXN0IjogIi4vbm9kZV9tb2R1bGVzLy5iaW4vbW9jaGEgdGVzdC8qLnRlc3QuanMiCiAgfSwKICAicmVwb3NpdG9yeSI6IHsKICAgICJ0eXBlIjogImdpdCIsCiAgICAidXJsIjogImdpdDovL2dpdGh1Yi5jb20vc2VsZmNvbnRhaW5lZC9kZWFwLmdpdCIKICB9LAogICJrZXl3b3JkcyI6IFsKICAgICJleHRlbmQiLAogICAgIm1lcmdlIiwKICAgICJtaXhpbiIsCiAgICAiZGVlcCIsCiAgICAic2hhbGxvdyIsCiAgICAiY2xvbmUiCiAgXSwKICAiYXV0aG9yIjogewogICAgIm5hbWUiOiAiQnJhZCBIYXJyaXMiLAogICAgImVtYWlsIjogImJtaGFycmlzQGdtYWlsLmNvbSIsCiAgICAidXJsIjogImh0dHA6Ly9zZWxmY29udGFpbmVkLnVzIgogIH0sCiAgImNvbnRyaWJ1dG9ycyI6IFsKICAgIHsKICAgICAgIm5hbWUiOiAiQnJhZCBIYXJyaXMiLAogICAgICAiZW1haWwiOiAiYm1oYXJyaXNAZ21haWwuY29tIiwKICAgICAgInVybCI6ICJodHRwOi8vc2VsZmNvbnRhaW5lZC51cyIKICAgIH0sCiAgICB7CiAgICAgICJuYW1lIjogIk1hdHQgRHVubGFwIiwKICAgICAgInVybCI6ICJodHRwOi8vZ2l0aHViLmNvbS9wcmVzdGF1bCIKICAgIH0KICBdLAogICJsaWNlbnNlIjogIkJTRCIsCiAgInJlYWRtZUZpbGVuYW1lIjogIlJFQURNRS5tZCIsCiAgImRldkRlcGVuZGVuY2llcyI6IHsKICAgICJtb2NoYSI6ICJ+MS45LjAiLAogICAgImNoYWkiOiAifjEuNi4wIgogIH0sCiAgInRlc3RsaW5nIjogewogICAgImJyb3dzZXJzIjogWwogICAgICAiaWUvOS4ubGF0ZXN0IiwKICAgICAgImZpcmVmb3gvMTkuLmxhdGVzdCIsCiAgICAgICJjaHJvbWUvMjUuLmxhdGVzdCIsCiAgICAgICJzYWZhcmkvbGF0ZXN0IiwKICAgICAgImlwaG9uZS82IiwKICAgICAgImlwYWQvNiIsCiAgICAgICJhbmRyb2lkLWJyb3dzZXIvbGF0ZXN0IgogICAgXSwKICAgICJoYXJuZXNzIjogIm1vY2hhLXRkZCIsCiAgICAiZmlsZXMiOiAidGVzdC8qLnRlc3QuanMiCiAgfSwKICAicmVhZG1lIjogIlshW2Jyb3dzZXIgc3VwcG9ydF0oaHR0cHM6Ly9jaS50ZXN0bGluZy5jb20vc2VsZmNvbnRhaW5lZC9kZWFwLnBuZyldKGh0dHA6Ly9jaS50ZXN0bGluZy5jb20vc2VsZmNvbnRhaW5lZC9kZWFwKVxuXG5bIVtCdWlsZCBTdGF0dXNdKGh0dHBzOi8vc2VjdXJlLnRyYXZpcy1jaS5vcmcvc2VsZmNvbnRhaW5lZC9kZWFwLnBuZz9icmFuY2g9bWFzdGVyKV0oaHR0cDovL3RyYXZpcy1jaS5vcmcvc2VsZmNvbnRhaW5lZC9kZWFwKVxuXG5kZWFwXG49PT09XG5cbmV4dGVuZCBhbmQgbWVyZ2Ugb2JqZWN0cywgZGVlcCBvciBzaGFsbG93LCBpbiBqYXZhc2NyaXB0XG5cblxuIyMjIGluc3RhbGxhdGlvblxuXG5gYGBiYXNoXG5ucG0gaW5zdGFsbCBkZWFwXG5gYGBcblxuYGBgamF2YXNjcmlwdFxudmFyIGRlYXAgPSByZXF1aXJlKCdkZWFwJyk7XG5gYGBcblxuIyMjIGJyb3dzZXIgdXNhZ2VcblxuKipkZWFwKiogYXNzdW1lcyBlczUsIHNvIHdlIHJlY29tbWVuZCB1c2luZyBhbiBlczUgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuICBbQnJvd3NlcmlmeV0oaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL25vZGUtYnJvd3NlcmlmeSkgaXMgYWxzbyByZWNvbW1lbmRlZCBhcyBhIG1lYW5zIHRvIHVzZSB0aGlzIG1vZHVsZSBjbGllbnQtc2lkZSwgYnV0IG90aGVyIG1vZHVsZSBsb2FkZXJzIGZvciBicm93c2VycyB3aWxsIHdvcmsgd2l0aCAqKmRlYXAqKiBhcyB3ZWxsIGlmIHlvdSBzaGltIGl0LlxuXG4jIyMgYXZhaWxhYmxlIGZ1bmN0aW9uc1xuXG4rIGRlYXAoKSBhbmQgZGVhcC5leHRlbmQoKSAtICoqZGVlcCBleHRlbmQqKlxuKyBkZWFwLm1lcmdlKCkgLSAqKmRlZXAgbWVyZ2UqKlxuKyBkZWFwLnVwZGF0ZSgpIC0gKipkZWVwIHVwZGF0ZSoqXG4rIGRlYXAuZXh0ZW5kU2hhbGxvdygpIC0gKipzaGFsbG93IGV4dGVuZCoqXG4rIGRlYXAubWVyZ2VTaGFsbG93KCkgLSAqKnNoYWxsb3cgbWVyZ2UqKlxuKyBkZWFwLnVwZGF0ZVNoYWxsb3coKSAtICoqc2hhbGxvdyB1cGRhdGUqKlxuKyBkZWFwLmNsb25lKCkgLSAqKmRlZXAgY2xvbmUqKlxuXG4tLS1cblxuIyMjIGRlYXAoKSBhbmQgZGVhcC5leHRlbmQoKVxuXG5EZWVwIGV4dGVuZC4gIENvcHkgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gb25lIG9iamVjdCBvbnRvIGFub3RoZXIsIGNsb25pbmcgb2JqZWN0cyBkZWVwbHkuXG5cblRha2VzICpuKiBudW1iZXIgb2YgYXJndW1lbnRzLCBtb2RpZmllcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHJldHVybnMgaXQuXG5cbmBgYGphdmFzY3JpcHRcbnZhciBhID0geyBuYW1lOiAnSm9lJyB9O1xuXG5kZWFwLmV4dGVuZChhLCB7IGFnZTogMjYgfSk7IC8vIHJldHVybnM6IGEgPT4geyBuYW1lOiAnSm9lJywgYWdlOiAyNiB9XG5kZWFwLmV4dGVuZCh7fSwgc29tZU9iaik7IC8vIGNsb25lIHNvbWVPYmpcbmBgYFxuXG4jIyMgZGVhcC5tZXJnZSgpXG5cbkRlZXAgbWVyZ2UuICBDb3B5IHByb3BlcnRpZXMgZnJvbSBvbmUgb2JqZWN0IHRvIGFub3RoZXIsIG5vdCByZXBsYWNpbmcgZXhpc3RpbmcgcHJvcGVydGllcy5cblxuVGFrZXMgKm4qIG51bWJlciBvZiBhcmd1bWVudHMsIG1vZGlmaWVzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgcmV0dXJucyBpdC5cblxuYGBgamF2YXNjcmlwdFxudmFyIGEgPSB7IG5hbWU6ICdKb2UnLCBhZGRyZXNzOiB7IG51bWJlcjogMTIzNCB9O1xuZGVhcC5tZXJnZShhLCB7IG5hbWU6ICdKYWNrJywgYWdlOiAyNiwgcGhvbmU6ICc1NTUtNTU1LTU1NTUnLCBhZGRyZXNzOiB7IG51bWJlcjogNDMyMSwgc3RyZWV0OiAnVW5pdmVyc2l0eSBCbHZkJyB9KTtcbi8vIHJldHVybnM6IGEgPT4geyBuYW1lOiAnSm9lJywgYWdlOiAyNiwgcGhvbmU6ICc1NTUtNTU1LTU1NTUnLCBhZGRyZXNzOiB7IG51bWJlcjogMTIzNCwgc3RyZWV0OiAnVW5pdmVyc2l0eSBCbHZkJyB9fVxuYGBgXG5cbiMjIyBkZWFwLnVwZGF0ZSgpXG5cbkRlZXAgdXBkYXRlLiAgRmlsbCBhbiBvYmplY3QncyBleGlzdGluZyBwcm9wZXJ0aWVzIGZyb20gYW5vdGhlciBvYmplY3QuXG5cblRha2VzICpuKiBudW1iZXIgb2YgYXJndW1lbnRzLCBtb2RpZmllcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHJldHVybnMgaXQuXG5cbmBgYGphdmFzY3JpcHRcbnZhciBhID0geyBuYW1lOiAnSm9lJywgcGhvbmU6ICcnIH07XG5kZWFwLnVwZGF0ZShhLCB7IGFnZTogMjYsIHBob25lOiAnNTU1LTU1NS01NTU1JyB9KTsgLy8gcmV0dXJuczogYSA9PiB7IG5hbWU6ICdKb2UnLCBwaG9uZTogJzU1NS01NTUtNTU1NScgfVxuYGBgXG5cbi0tLVxuXG4jIyBzaGFsbG93IG9ubHlcblxuSWYgeW91IHByZWZlciBhIHNoYWxsb3ctb25seSBpbnN0YW5jZSBvZiAqKmRlYXAqKiB5b3UgY2FuIHJlcXVpcmUgaXQgc3BlY2lmaWNhbGx5XG5cbmBgYGphdmFzY3JpcHRcbnZhciBkZWFwID0gcmVxdWlyZSgnZGVhcC9zaGFsbG93Jyk7XG5cbmRlYXAoKSAmJiBkZWFwLmV4dGVuZCgpOyAvLyBzaGFsbG93IGV4dGVuZFxuZGVhcC5tZXJnZSgpOyAvL3NoYWxsb3cgbWVyZ2VcbmRlYXAudXBkYXRlKCk7IC8vc2hhbGxvdyB1cGRhdGVcbmRlYXAuY2xvbmUoKTsgLy8gZGVlcCBjbG9uZVxuYGBgXG5cbi4uLnRoZSBlbmRcbiIsCiAgImJ1Z3MiOiB7CiAgICAidXJsIjogImh0dHBzOi8vZ2l0aHViLmNvbS9zZWxmY29udGFpbmVkL2RlYXAvaXNzdWVzIgogIH0sCiAgIl9pZCI6ICJkZWFwQDAuMi4wIiwKICAiX2Zyb20iOiAiZGVhcEB+MC4yLjAiCn0K",
        "12938380d91199c2a4e563439e5d0bec": "MTI5MzgzODBkOTExOTljMmE0ZTU2MzQzOWU1ZDBiZWM=",
        "69b3386a9d2baad0f210b3995381105f": "ewogICJuYW1lIjogImpzY2siLAogICJ2ZXJzaW9uIjogIjAuMS4zIiwKICAiZGVzY3JpcHRpb24iOiAiSlNPTiBTY2hlbWEgQ29tcGlsZWQgY2hlY0siLAogICJtYWluIjogImxpYi9pbmRleC5qcyIsCiAgImZpbGVzIjogWwogICAgImxpYi8iLAogICAgIlJFQURNRS5tZCIKICBdLAogICJkZXBlbmRlbmNpZXMiOiB7CiAgICAiZGVhcCI6ICJ+MC4yLjAiCiAgfSwKICAiZGV2RGVwZW5kZW5jaWVzIjogewogICAgInRlc3RpZnkiOiAifjAuMi44IiwKICAgICJtaWNyb3RpbWUiOiAifjAuNC4wIiwKICAgICJKU1YiOiAifjQuMC4yIiwKICAgICJqc29uc2NoZW1hIjogIn4wLjQuMCIsCiAgICAiY29mZmVlLXNjcmlwdCI6ICJ+MS42LjMiLAogICAgImdsb2IiOiAifjMuMi42IiwKICAgICJzaW1wbGUtaHR0cC1zZXJ2ZXIiOiAifjAuMS44IgogIH0sCiAgInJlcG9zaXRvcnkiOiB7CiAgICAidHlwZSI6ICJnaXQiLAogICAgInVybCI6ICJnaXRAZ2l0aHViLmNvbTphdXRvbWF0dGhldy9qc2NrLmdpdCIKICB9LAogICJhdXRob3IiOiB7CiAgICAibmFtZSI6ICJNYXR0aGV3IEtpbmciLAogICAgImVtYWlsIjogImF1dG9tYXR0aGV3QGdtYWlsLmNvbSIKICB9LAogICJsaWNlbnNlIjogIk1JVCIsCiAgInJlYWRtZSI6ICIjIEpTT04gU2NoZW1hIENvbXBpbGVkIENoZWNLXG5cbkZhc3QgdmFsaWRhdGlvbiBhZ2FpbnN0IEpTT04gU2NoZW1hIERyYWZ0IDNcblxuIyMgSW5zdGFsbGF0aW9uXG5cbmBgYFxuJCBucG0gaW5zdGFsbCBqc2NrXG5gYGBcblxuXG4jIyBBYm91dFxuXG5cbkpTQ0sgaXMgYSBcImNvbXBpbGluZ1wiIHNjaGVtYSB2YWxpZGF0b3IsIG1lYW5pbmcgdGhhdCBpdCB0cmF2ZXJzZXMgYSBzY2hlbWEgb25seSBvbmNlIChhdCBpbnN0YW50aWF0aW9uKVxuYW5kIGdlbmVyYXRlcyB0aGUgZnVuY3Rpb25zIG5lZWRlZCB0byB2YWxpZGF0ZSBkb2N1bWVudHMgYWdhaW5zdCB0aGUgc2NoZW1hLlxuQnkgZG9pbmcgc28sIGl0IGF2b2lkcyB0aGUgbmVlZCB0byByZS10cmF2ZXJzZSB0aGUgc2NoZW1hIHN0cnVjdHVyZSBmb3IgZXZlcnkgZG9jdW1lbnQgaXQgdmFsaWRhdGVzLlxuVGhpcyBsZWFkcyB0byBzdWJzdGFudGlhbCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMuXG5cbkZvciB0aGUgaW5pdGlhbCAoMC4xLngpIHJlbGVhc2UsIEpTQ0sgd2lsbCBvbmx5IHRlbGwgeW91IHdoZXRoZXIgYSBkb2N1bWVudCBwYXNzZXMgdmFsaWRhdGlvbiwgbm90IHdoZXJlIGl0IGZhaWxlZCBvciB3aHkuXG5cblN1cHBvcnRzIG1vc3Qgb2YgSlNPTiBTY2hlbWEgRHJhZnQgMy4gW0RvY3VtZW50YXRpb25dW2RyYWZ0M19kb2NdIGFuZCBbaW1wbGVtZW50YXRpb25dW2RyYWZ0M19pbXBsXS5cblxuXG4jIyBVc2FnZVxuXG5cbmBgYC5jb2ZmZWVcblxuVmFsaWRhdG9yID0gcmVxdWlyZShcIi4uL3NyYy9pbmRleFwiKS5kcmFmdDNcblxuIyBhIHNjaGVtYSB3aXRob3V0IGFuIFwiaWRcIiBkZWNsYXJhdGlvblxuXG52YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yXG4gIHR5cGU6IFwib2JqZWN0XCJcbiAgcHJvcGVydGllczpcbiAgICB1c2VyOlxuICAgICAgdHlwZTogXCJvYmplY3RcIlxuICAgICAgcHJvcGVydGllczpcbiAgICAgICAgbG9naW46XG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgcGF0dGVybjogXCJeW1xcXFx3XFxcXGRfXXszLDMyfSRcIlxuICAgICAgICBlbWFpbDpcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG5cbnt2YWxpZH0gPSB2YWxpZGF0b3IudmFsaWRhdGVcbiAgdXNlcjpcbiAgICBsb2dpbjogXCJhdXRvbWF0dGhld1wiXG4gICAgZW1haWw6IFwiYXV0b21hdHRoZXdAbWFpbGluYXRvci5jb21cIlxuXG5jb25zb2xlLmxvZyBcIkFub255bW91cyBzY2hlbWE6XCIsIHZhbGlkXG5cblxuYGBgXG5cblxuIyMjIFtBZHZhbmNlZCB1c2FnZSBleGFtcGxlc10oZXhhbXBsZXMvZHJhZnQzX2FkdmFuY2VkLmNvZmZlZSlcblxuXG5cbiMjIENvdmVyYWdlXG5cbkN1cnJlbnRseSBwYXNzaW5nIHRoZSBjYW5vbmljYWwgW3Rlc3Qgc3VpdGVdW2Nhbm9uaWNhbF0gZm9yIGRyYWZ0MyBleGNlcHQgZm9yIHRoZXNlIGl0ZW1zOlxuXG4qIGByZWZSZW1vdGVgIChUcnlpbmcgdG8ga2VlcCB0aGlzIGxpYiBzeW5jaHJvbm91cyBmb3IgdjAuMS54KVxuKiBgcmVmYFxuICAqIHJlbW90ZSByZWYsIGNvbnRhaW5pbmcgcmVmcyBpdHNlbGZcbiogYHVuaXF1ZUl0ZW1zYFxuKiBgb3B0aW9uYWwvemVyb1Rlcm1pbmF0ZWRGbG9hdHNgXG4qIGBvcHRpb25hbC9mb3JtYXRgIChzb21lIG9mIHRoZSByZWdleGVzIGJvcnJvd2VkIGZyb20gW3RkZWdydW50J3MgdmFsaWRhdG9yXShodHRwczovL2dpdGh1Yi5jb20vdGRlZ3J1bnQvanNvbnNjaGVtYSkgYXJlbid0IHdvcmtpbmcgZm9yIG1lKVxuICAqIHZhbGlkYXRpb24gb2YgZGF0ZS10aW1lIHN0cmluZ3NcbiAgKiB2YWxpZGF0aW9uIG9mIENTUyBjb2xvcnNcbiAgKiB2YWxpZGF0aW9uIG9mIGhvc3QgbmFtZXNcblxuXG4jIyMgTWFuYWdpbmcgcmVzb2x1dGlvbiBzY29wZSB3aXRoIHRoZSBcImlkXCIgYXR0cmlidXRlXG5cblxuSlNDSyBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmdWxsIHJhbmdlIG9mIHNjb3BlIG1hbmlwdWxhdGlvbnMgc3VnZ2VzdGVkIGJ5IGRyYWZ0cyAzIGFuZCA0LiAgSXQgdXNlcyBcImlkXCIgZGVjbGFyYXRpb25zIG9ubHkgaW4gdGhlc2UgY2FzZXM6XG5cbiogYXQgdGhlIHRvcCBsZXZlbCBvZiBhIHNjaGVtYSwgdG8gcHJvdmlkZSBhIG5hbWVzcGFjZSBmb3Igc2NoZW1hcyBub3QgbG9hZGVkIGZyb20gVVJJcy5cbiogbm9uLUpTT04tcG9pbnRlciBmcmFnbWVudHMgKGBcImlkXCI6IFwiI3VzZXJcImApLCB3aGljaCBzZXJ2ZSBtZXJlbHkgYXMgYWxpYXNlcyBmb3Igc3BlY2lmaWMgc3Vic2NoZW1hcywgYW5kIGFyZSB0aHVzIGNvbnZlbmllbnQgYW5kIHVuYW1iaWd1b3VzLlxuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgdG9waWMgb2Ygc2NvcGUgbWFuaXB1bGF0aW9uLCBzZWUgdGhpcyBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2pzb24tc2NoZW1hL2pzb24tc2NoZW1hL2lzc3Vlcy83Ny5cblxuXG4jIyBCZW5jaG1hcmtzXG5cblJlc3VsdHMgb2YgYSBzaW1wbGUgKHByb2JhYmx5IGZsYXdlZCkgW2JlbmNobWFyayBhZ2FpbnN0IG90aGVyIGxpYnNdKC4vYmVuY2htYXJrcy9ldmVudC5jb2ZmZWUpLiA4IGl0ZXJhdGlvbnMuICBVbml0cyBhcmUgbXMuXG5cbmBgYFxuXG5KU0NLOiB2YWxpZCBkb2N1bWVudCwgNDAwIHRpbWVzIHsgbWF4OiAyLjU5NixcbiAgbWVkaWFuOiAwLjQ5NCxcbiAgbWluOiAwLjQ5MSxcbiAgbWVhbjogMC43NixcbiAgc3RkRGV2OiAwLjY5NDAwMzQyMjE4MTc2NDMsXG4gIHNhbXBsZV9zaXplOiA4IH1cblxuanNvbnNjaGVtYTogdmFsaWQgZG9jdW1lbnQsIDQwMCB0aW1lcyB7IG1heDogMjI0LjgxOCxcbiAgbWVkaWFuOiAxOTQuNTAzLFxuICBtaW46IDE4My45NjUsXG4gIG1lYW46IDE5OC44Mzg3NSxcbiAgc3RkRGV2OiAxNC4xMDI3NjkzMzU3NTQ1OTYsXG4gIHNhbXBsZV9zaXplOiA4IH1cblxuSlNWOiB2YWxpZCBkb2N1bWVudCwgNDAwIHRpbWVzIHsgbWF4OiA1Nzc4LjA1OCxcbiAgbWVkaWFuOiA1NzA3LjIzOSxcbiAgbWluOiA1NjY0LjQ2LFxuICBtZWFuOiA1NzEzLjM2ODM3NSxcbiAgc3RkRGV2OiAzOC4zMDQwNjcxNDAyNDQ2NCxcbiAgc2FtcGxlX3NpemU6IDggfVxuXG5gYGBcblxuSSBmaW5kIGl0IGRpZmZpY3VsdCB0byBiZWxpZXZlIEpTViBpcyBhY3R1YWxseSB0aGF0IHNsb3csIHNvIGl0J3MgcHJvYmFibHkgbXkgZmF1bHQuIFBvc3NpYmx5IGluY29ycmVjdCB1c2FnZSBvZiBKU1YuXG5cblxuIyMgUGxhbnNcblxuIyMjIDAuMS4wXG5cbiogQm9vbGVhbiB2YWxpZGF0aW9uLlxuKiBDb3JyZWN0IGNvdmVyYWdlIG9mIG1vc3Qgb2YgRHJhZnQgM1xuKiBiZW5jaG1hcmtpbmcgc2NoZW1hcyBvZiB2YXJ5aW5nIGxldmVscyBvZiBjb21wbGV4aXR5XG5cbiMjIyAwLjIuMFxuXG4qIHZhbGlkYXRpb24gZXJyb3IgcmVwb3J0c1xuKiBjb21wbGV0ZSBzdXBwb3J0IGZvciBcImZvcm1hdFwiXG4qIGFkZGluZyBtb3JlIGNvbXByZWhlbnNpdmUgdGVzdHMgdG8gdGhlIG9mZmljaWFsIHRlc3Qgc3VpdGVcbiogc3VwcG9ydCByZW1vdGUgcmVmZXJlbmNlc1xuXG4jIyMgMC4zXG5cbiogU3VwcG9ydCBEcmFmdCA0XG5cbltkcmFmdDNfZG9jXTpodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC16eXAtanNvbi1zY2hlbWEtMDNcbltkcmFmdDNfaW1wbF06aHR0cHM6Ly9naXRodWIuY29tL2pzb24tc2NoZW1hL2pzb24tc2NoZW1hL3RyZWUvbWFzdGVyL2RyYWZ0LTAzXG5bY2Fub25pY2FsXTpodHRwczovL2dpdGh1Yi5jb20vanNvbi1zY2hlbWEvSlNPTi1TY2hlbWEtVGVzdC1TdWl0ZVxuXG4iLAogICJyZWFkbWVGaWxlbmFtZSI6ICJSRUFETUUubWQiLAogICJidWdzIjogewogICAgInVybCI6ICJodHRwczovL2dpdGh1Yi5jb20vYXV0b21hdHRoZXcvanNjay9pc3N1ZXMiCiAgfSwKICAiX2lkIjogImpzY2tAMC4xLjMiLAogICJfZnJvbSI6ICJqc2NrQDAuMS4zIgp9Cg==",
        "18afc51605ce5367f79707f21337f219": "MThhZmM1MTYwNWNlNTM2N2Y3OTcwN2YyMTMzN2YyMTk=",
        "6057cd0902b262138421abb292e2b8af": "NjA1N2NkMDkwMmIyNjIxMzg0MjFhYmIyOTJlMmI4YWY=",
        "15c17f74b3a4728e12bc597d2db090fa": "MTVjMTdmNzRiM2E0NzI4ZTEyYmM1OTdkMmRiMDkwZmE=",
        "b11267eae7cb3a8dd3670a00ed307031": "YjExMjY3ZWFlN2NiM2E4ZGQzNjcwYTAwZWQzMDcwMzE=",
        "c4f9141dbd0d7a4e3dd3d1dc0a64c667": "YzRmOTE0MWRiZDBkN2E0ZTNkZDNkMWRjMGE2NGM2Njc=",
        "5d6e2c2d895132330e91af96bc1409c7": "NWQ2ZTJjMmQ4OTUxMzIzMzBlOTFhZjk2YmMxNDA5Yzc=",
        "8f99cc2b75044ae1f45cefc6948e42b3": "OGY5OWNjMmI3NTA0NGFlMWY0NWNlZmM2OTQ4ZTQyYjM=",
        "e78828afe729e92d62b73d30c483888f": "ZTc4ODI4YWZlNzI5ZTkyZDYyYjczZDMwYzQ4Mzg4OGY=",
        "223f09f17e4aff9f2d05493c688f7934": "MjIzZjA5ZjE3ZTRhZmY5ZjJkMDU0OTNjNjg4Zjc5MzQ=",
        "ddeff58ff67e5d2d686891fc66ebb2b7": "ZGRlZmY1OGZmNjdlNWQyZDY4Njg5MWZjNjZlYmIyYjc=",
        "7b51c3f0555ccb0c0f1fcd91d389ea1a": "N2I1MWMzZjA1NTVjY2IwYzBmMWZjZDkxZDM4OWVhMWE=",
        "d0c9d6cc2490c964b789d43ae4803b7b": "ZDBjOWQ2Y2MyNDkwYzk2NGI3ODlkNDNhZTQ4MDNiN2I=",
        "b499eb63a89b9e6fb99ef1209a65ace6": "YjQ5OWViNjNhODliOWU2ZmI5OWVmMTIwOWE2NWFjZTY=",
        "54c69a095dc8e4a9173bd8284c4e8ad7": "NTRjNjlhMDk1ZGM4ZTRhOTE3M2JkODI4NGM0ZThhZDc=",
        "f0d5935f094eb3d9fb70c67795bd4caf": "ZjBkNTkzNWYwOTRlYjNkOWZiNzBjNjc3OTViZDRjYWY=",
        "a8aae685be6eeb8ec844ae9c4f5fd189": "YThhYWU2ODViZTZlZWI4ZWM4NDRhZTljNGY1ZmQxODk="
      },
      modules: {
        api: {
          "assert": "c4f9141dbd0d7a4e3dd3d1dc0a64c667",
          "http": "5d6e2c2d895132330e91af96bc1409c7",
          "https": "8f99cc2b75044ae1f45cefc6948e42b3",
          "fs": "e78828afe729e92d62b73d30c483888f",
          "module": "223f09f17e4aff9f2d05493c688f7934",
          "util": "ddeff58ff67e5d2d686891fc66ebb2b7",
          "path": "7b51c3f0555ccb0c0f1fcd91d389ea1a",
          "url": "d0c9d6cc2490c964b789d43ae4803b7b",
          "events": "b499eb63a89b9e6fb99ef1209a65ace6",
          "querystring": "54c69a095dc8e4a9173bd8284c4e8ad7",
          "stream": "f0d5935f094eb3d9fb70c67795bd4caf",
          "crypto": "a8aae685be6eeb8ec844ae9c4f5fd189"
        },

        function: {

          "191e63738fc82d8d97b4bc0ab16b2074": // from: application.coffee
          function(exports, require, module, __filename, __dirname) {
            var Client, Testify, assert;

            Testify = require("testify");

            assert = require("assert");

            Client = require("patchboard-js");

            window.onload = function() {
              Testify.reporter = new Testify.DOMReporter("testify", 1000);
              return Client.discover("http://localhost:1979/", function(error, client) {
                var resources;
                if (error) {
                  throw error;
                }
                resources = client.resources;
                return Testify.test("Trivial API", function(suite) {
                  return suite.test("create a user", function(context) {
                    var login;
                    login = Math.random().toString();
                    return resources.users.create({
                      login: login
                    }, function(error, response) {
                      context.test("Expected response", function() {
                        return assert.ifError(error);
                      });
                      context.test("has expected fields", function() {
                        var resource;
                        resource = response.resource;
                        assert.equal(resource.login, login);
                        assert.ok(resource.url);
                        return assert.ok(!resource.email);
                      });
                      context.test("has expected subresources", function() {
                        var resource;
                        resource = response.resource;
                        return assert.equal(resource.questions.constructor, Function);
                      });
                      suite.test("searching for a user", function(context) {
                        return resources.user_search({
                          login: login
                        }).get(function(error, response) {
                          context.test("Expected response", function() {
                            return assert.ifError(error);
                          });
                          return context.test("user is good", function() {
                            var user;
                            user = response.resource;
                            return assert.equal(user.resource_type, "user");
                          });
                        });
                      });
                      return suite.test("asking for a question", function(context) {
                        var resource;
                        resource = response.resource;
                        return resource.questions({
                          category: "Science"
                        }).ask(function(error, _arg) {
                          var resource;
                          resource = _arg.resource;
                          context.test("Expected response", function() {
                            return assert.ifError(error);
                          });
                          context.test("question has expected fields", function() {
                            assert.ok(resource.url);
                            assert.ok(resource.question);
                            return assert.ok("abcd".split("").every(function(item) {
                              return resource[item];
                            }));
                          });
                          return suite.test("answering the question", function(context) {
                            return resource.answer({
                              letter: "d"
                            }, function(error, response) {
                              context.test("Expected response", function() {
                                return assert.ifError(error);
                              });
                              return context.test("success", function() {
                                var result;
                                result = response.resource;
                                assert.equal(result.success, true);
                                assert.equal(result.correct, "d");
                                return suite.test("attempting to answer again", function(context) {
                                  return resource.answer({
                                    letter: "d"
                                  }, function(error, response) {
                                    return context.test("receive expected HTTP error", function() {
                                      var data;
                                      assert.ok(error);
                                      assert.equal(error.status, 409);
                                      data = JSON.parse(error.response.body);
                                      return assert.equal(data.message, "Question has already been answered");
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            };

          },

          "23a08b63b337fc80259e39814c3304f5": // from: node_modules/testify/node_modules/colors/colors.js
          function(exports, require, module, __filename, __dirname) {
            /*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

            var isHeadless = false;

            if (typeof module !== 'undefined') {
              isHeadless = true;
            }

            if (!isHeadless) {
              var exports = {};
              var module = {};
              var colors = exports;
              exports.mode = "browser";
            } else {
              exports.mode = "console";
            }

            //
            // Prototypes the string object to have additional method calls that add terminal colors
            //
            var addProperty = function(color, func) {
              exports[color] = function(str) {
                return func.apply(str);
              };
              String.prototype.__defineGetter__(color, func);
            };

            function stylize(str, style) {

              var styles;

              if (exports.mode === 'console') {
                styles = {
                  //styles
                  'bold': ['\x1B[1m', '\x1B[22m'],
                  'italic': ['\x1B[3m', '\x1B[23m'],
                  'underline': ['\x1B[4m', '\x1B[24m'],
                  'inverse': ['\x1B[7m', '\x1B[27m'],
                  'strikethrough': ['\x1B[9m', '\x1B[29m'],
                  //text colors
                  //grayscale
                  'white': ['\x1B[37m', '\x1B[39m'],
                  'grey': ['\x1B[90m', '\x1B[39m'],
                  'black': ['\x1B[30m', '\x1B[39m'],
                  //colors
                  'blue': ['\x1B[34m', '\x1B[39m'],
                  'cyan': ['\x1B[36m', '\x1B[39m'],
                  'green': ['\x1B[32m', '\x1B[39m'],
                  'magenta': ['\x1B[35m', '\x1B[39m'],
                  'red': ['\x1B[31m', '\x1B[39m'],
                  'yellow': ['\x1B[33m', '\x1B[39m'],
                  //background colors
                  //grayscale
                  'whiteBG': ['\x1B[47m', '\x1B[49m'],
                  'greyBG': ['\x1B[49;5;8m', '\x1B[49m'],
                  'blackBG': ['\x1B[40m', '\x1B[49m'],
                  //colors
                  'blueBG': ['\x1B[44m', '\x1B[49m'],
                  'cyanBG': ['\x1B[46m', '\x1B[49m'],
                  'greenBG': ['\x1B[42m', '\x1B[49m'],
                  'magentaBG': ['\x1B[45m', '\x1B[49m'],
                  'redBG': ['\x1B[41m', '\x1B[49m'],
                  'yellowBG': ['\x1B[43m', '\x1B[49m']
                };
              } else if (exports.mode === 'browser') {
                styles = {
                  //styles
                  'bold': ['<b>', '</b>'],
                  'italic': ['<i>', '</i>'],
                  'underline': ['<u>', '</u>'],
                  'inverse': ['<span style="background-color:black;color:white;">', '</span>'],
                  'strikethrough': ['<del>', '</del>'],
                  //text colors
                  //grayscale
                  'white': ['<span style="color:white;">', '</span>'],
                  'grey': ['<span style="color:gray;">', '</span>'],
                  'black': ['<span style="color:black;">', '</span>'],
                  //colors
                  'blue': ['<span style="color:blue;">', '</span>'],
                  'cyan': ['<span style="color:cyan;">', '</span>'],
                  'green': ['<span style="color:green;">', '</span>'],
                  'magenta': ['<span style="color:magenta;">', '</span>'],
                  'red': ['<span style="color:red;">', '</span>'],
                  'yellow': ['<span style="color:yellow;">', '</span>'],
                  //background colors
                  //grayscale
                  'whiteBG': ['<span style="background-color:white;">', '</span>'],
                  'greyBG': ['<span style="background-color:gray;">', '</span>'],
                  'blackBG': ['<span style="background-color:black;">', '</span>'],
                  //colors
                  'blueBG': ['<span style="background-color:blue;">', '</span>'],
                  'cyanBG': ['<span style="background-color:cyan;">', '</span>'],
                  'greenBG': ['<span style="background-color:green;">', '</span>'],
                  'magentaBG': ['<span style="background-color:magenta;">', '</span>'],
                  'redBG': ['<span style="background-color:red;">', '</span>'],
                  'yellowBG': ['<span style="background-color:yellow;">', '</span>']
                };
              } else if (exports.mode === 'none') {
                return str + '';
              } else {
                console.log('unsupported mode, try "browser", "console" or "none"');
              }
              return styles[style][0] + str + styles[style][1];
            }

            function applyTheme(theme) {

              //
              // Remark: This is a list of methods that exist
              // on String that you should not overwrite.
              //
              var stringPrototypeBlacklist = ['__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt', 'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring', 'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'];

              Object.keys(theme).forEach(function(prop) {
                if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
                  console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
                } else {
                  if (typeof(theme[prop]) === 'string') {
                    addProperty(prop, function() {
                      return exports[theme[prop]](this);
                    });
                  } else {
                    addProperty(prop, function() {
                      var ret = this;
                      for (var t = 0; t < theme[prop].length; t++) {
                        ret = exports[theme[prop][t]](ret);
                      }
                      return ret;
                    });
                  }
                }
              });
            }


            //
            // Iterate through all default styles and colors
            //
            var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
            x.forEach(function(style) {

              // __defineGetter__ at the least works in more browsers
              // http://robertnyman.com/javascript/javascript-getters-setters.html
              // Object.defineProperty only works in Chrome
              addProperty(style, function() {
                return stylize(this, style);
              });
            });

            function sequencer(map) {
              return function() {
                if (!isHeadless) {
                  return this.replace(/( )/, '$1');
                }
                var exploded = this.split(""),
                  i = 0;
                exploded = exploded.map(map);
                return exploded.join("");
              };
            }

            var rainbowMap = (function() {
              var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
              return function(letter, i, exploded) {
                if (letter === " ") {
                  return letter;
                } else {
                  return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
                }
              };
            })();

            exports.themes = {};

            exports.addSequencer = function(name, map) {
              addProperty(name, sequencer(map));
            };

            exports.addSequencer('rainbow', rainbowMap);
            exports.addSequencer('zebra', function(letter, i, exploded) {
              return i % 2 === 0 ? letter : letter.inverse;
            });

            exports.setTheme = function(theme) {
              if (typeof theme === 'string') {
                try {
                  exports.themes[theme] = require(theme);
                  applyTheme(exports.themes[theme]);
                  return exports.themes[theme];
                } catch (err) {
                  console.log(err);
                  return err;
                }
              } else {
                applyTheme(theme);
              }
            };


            addProperty('stripColors', function() {
              return ("" + this).replace(/\x1B\[\d+m/g, '');
            });

            // please no
            function zalgo(text, options) {
              var soul = {
                "up": ['̍', '̎', '̄', '̅', '̿', '̑', '̆', '̐', '͒', '͗', '͑', '̇', '̈', '̊', '͂', '̓', '̈', '͊', '͋', '͌', '̃', '̂', '̌', '͐', '̀', '́', '̋', '̏', '̒', '̓', '̔', '̽', '̉', 'ͣ', 'ͤ', 'ͥ', 'ͦ', 'ͧ', 'ͨ', 'ͩ', 'ͪ', 'ͫ', 'ͬ', 'ͭ', 'ͮ', 'ͯ', '̾', '͛', '͆', '̚'],
                "down": ['̖', '̗', '̘', '̙', '̜', '̝', '̞', '̟', '̠', '̤', '̥', '̦', '̩', '̪', '̫', '̬', '̭', '̮', '̯', '̰', '̱', '̲', '̳', '̹', '̺', '̻', '̼', 'ͅ', '͇', '͈', '͉', '͍', '͎', '͓', '͔', '͕', '͖', '͙', '͚', '̣'],
                "mid": ['̕', '̛', '̀', '́', '͘', '̡', '̢', '̧', '̨', '̴', '̵', '̶', '͜', '͝', '͞', '͟', '͠', '͢', '̸', '̷', '͡', ' ҉']
              },
              all = [].concat(soul.up, soul.down, soul.mid),
                zalgo = {};

              function randomNumber(range) {
                var r = Math.floor(Math.random() * range);
                return r;
              }

              function is_char(character) {
                var bool = false;
                all.filter(function(i) {
                  bool = (i === character);
                });
                return bool;
              }

              function heComes(text, options) {
                var result = '',
                  counts, l;
                options = options || {};
                options["up"] = options["up"] || true;
                options["mid"] = options["mid"] || true;
                options["down"] = options["down"] || true;
                options["size"] = options["size"] || "maxi";
                text = text.split('');
                for (l in text) {
                  if (is_char(l)) {
                    continue;
                  }
                  result = result + text[l];
                  counts = {
                    "up": 0,
                    "down": 0,
                    "mid": 0
                  };
                  switch (options.size) {
                  case 'mini':
                    counts.up = randomNumber(8);
                    counts.min = randomNumber(2);
                    counts.down = randomNumber(8);
                    break;
                  case 'maxi':
                    counts.up = randomNumber(16) + 3;
                    counts.min = randomNumber(4) + 1;
                    counts.down = randomNumber(64) + 3;
                    break;
                  default:
                    counts.up = randomNumber(8) + 1;
                    counts.mid = randomNumber(6) / 2;
                    counts.down = randomNumber(8) + 1;
                    break;
                  }

                  var arr = ["up", "mid", "down"];
                  for (var d in arr) {
                    var index = arr[d];
                    for (var i = 0; i <= counts[index]; i++) {
                      if (options[index]) {
                        result = result + soul[index][randomNumber(soul[index].length)];
                      }
                    }
                  }
                }
                return result;
              }
              return heComes(text);
            }


            // don't summon zalgo
            addProperty('zalgo', function() {
              return zalgo(this);
            });

          },

          "d6a358179f5edaab86caf4d73a100b9a": // from: node_modules/testify/node_modules/colors/example.js
          function(exports, require, module, __filename, __dirname) {
            var colors = require('./colors');

            //colors.mode = "browser";

            var test = colors.red("hopefully colorless output");
            console.log('Rainbows are fun!'.rainbow);
            console.log('So '.italic + 'are'.underline + ' styles! '.bold + 'inverse'.inverse); // styles not widely supported
            console.log('Chains are also cool.'.bold.italic.underline.red); // styles not widely supported
            //console.log('zalgo time!'.zalgo);
            console.log(test.stripColors);
            console.log("a".grey + " b".black);
            console.log("Zebras are so fun!".zebra);
            console.log('background color attack!'.black.whiteBG)

            //
            // Remark: .strikethrough may not work with Mac OS Terminal App
            //
            console.log("This is " + "not".strikethrough + " fun.");
            console.log(colors.rainbow('Rainbows are fun!'));
            console.log(colors.italic('So ') + colors.underline('are') + colors.bold(' styles! ') + colors.inverse('inverse')); // styles not widely supported
            console.log(colors.bold(colors.italic(colors.underline(colors.red('Chains are also cool.'))))); // styles not widely supported
            //console.log(colors.zalgo('zalgo time!'));
            console.log(colors.stripColors(test));
            console.log(colors.grey("a") + colors.black(" b"));

            colors.addSequencer("america", function(letter, i, exploded) {
              if (letter === " ") return letter;
              switch (i % 3) {
              case 0:
                return letter.red;
              case 1:
                return letter.white;
              case 2:
                return letter.blue;
              }
            });

            colors.addSequencer("random", (function() {
              var available = ['bold', 'underline', 'italic', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];

              return function(letter, i, exploded) {
                return letter === " " ? letter : letter[available[Math.round(Math.random() * (available.length - 1))]];
              };
            })());

            console.log("AMERICA! F--K YEAH!".america);
            console.log("So apparently I've been to Mars, with all the little green men. But you know, I don't recall.".random);

            //
            // Custom themes
            //

            // Load theme with JSON literal
            colors.setTheme({
              silly: 'rainbow',
              input: 'grey',
              verbose: 'cyan',
              prompt: 'grey',
              info: 'green',
              data: 'grey',
              help: 'cyan',
              warn: 'yellow',
              debug: 'blue',
              error: 'red'
            });

            // outputs red text
            console.log("this is an error".error);

            // outputs yellow text
            console.log("this is a warning".warn);

            // outputs grey text
            console.log("this is an input".input);

            // Load a theme from file
            colors.setTheme('./themes/winston-dark.js');

            console.log("this is an input".input);


          },

          "f281098536a9e02598817e541e8e15a3": // from: node_modules/testify/node_modules/colors/test.js
          function(exports, require, module, __filename, __dirname) {
            var assert = require('assert'),
              colors = require('./colors');

            var s = 'string';

            function a(s, code) {
              return '\x1B[' + code.toString() + 'm' + s + '\x1B[39m';
            }

            function aE(s, color, code) {
              assert.equal(s[color], a(s, code));
              assert.equal(colors[color](s), a(s, code));
              assert.equal(s[color], colors[color](s));
              assert.equal(s[color].stripColors, s);
              assert.equal(s[color].stripColors, colors.stripColors(s));
            }

            function h(s, color) {
              return '<span style="color:' + color + ';">' + s + '</span>';
            }

            var stylesColors = ['white', 'black', 'blue', 'cyan', 'green', 'magenta', 'red', 'yellow'];
            var stylesAll = stylesColors.concat(['bold', 'italic', 'underline', 'inverse', 'rainbow']);

            colors.mode = 'console';
            assert.equal(s.bold, '\x1B[1m' + s + '\x1B[22m');
            assert.equal(s.italic, '\x1B[3m' + s + '\x1B[23m');
            assert.equal(s.underline, '\x1B[4m' + s + '\x1B[24m');
            assert.equal(s.strikethrough, '\x1B[9m' + s + '\x1B[29m');
            assert.equal(s.inverse, '\x1B[7m' + s + '\x1B[27m');
            assert.ok(s.rainbow);
            aE(s, 'white', 37);
            aE(s, 'grey', 90);
            aE(s, 'black', 30);
            aE(s, 'blue', 34);
            aE(s, 'cyan', 36);
            aE(s, 'green', 32);
            aE(s, 'magenta', 35);
            aE(s, 'red', 31);
            aE(s, 'yellow', 33);
            assert.equal(s, 'string');

            colors.setTheme({
              error: 'red'
            });

            assert.equal(typeof("astring".red), 'string');
            assert.equal(typeof("astring".error), 'string');

            colors.mode = 'browser';
            assert.equal(s.bold, '<b>' + s + '</b>');
            assert.equal(s.italic, '<i>' + s + '</i>');
            assert.equal(s.underline, '<u>' + s + '</u>');
            assert.equal(s.strikethrough, '<del>' + s + '</del>');
            assert.equal(s.inverse, '<span style="background-color:black;color:white;">' + s + '</span>');
            assert.ok(s.rainbow);
            stylesColors.forEach(function(color) {
              assert.equal(s[color], h(s, color));
              assert.equal(colors[color](s), h(s, color));
            });

            assert.equal(typeof("astring".red), 'string');
            assert.equal(typeof("astring".error), 'string');

            colors.mode = 'none';
            stylesAll.forEach(function(style) {
              assert.equal(s[style], s);
              assert.equal(colors[style](s), s);
            });

            assert.equal(typeof("astring".red), 'string');
            assert.equal(typeof("astring".error), 'string');

          },

          "a5e50735f6652e9757ac1c7a63cf85ef": // from: node_modules/testify/node_modules/colors/themes/winston-dark.js
          function(exports, require, module, __filename, __dirname) {
            module['exports'] = {
              silly: 'rainbow',
              input: 'black',
              verbose: 'cyan',
              prompt: 'grey',
              info: 'green',
              data: 'grey',
              help: 'cyan',
              warn: 'yellow',
              debug: 'blue',
              error: 'red'
            };
          },

          "8ae0394cb9f1165729513b6c35767b27": // from: node_modules/testify/node_modules/colors/themes/winston-light.js
          function(exports, require, module, __filename, __dirname) {
            module['exports'] = {
              silly: 'rainbow',
              input: 'grey',
              verbose: 'cyan',
              prompt: 'grey',
              info: 'green',
              data: 'grey',
              help: 'cyan',
              warn: 'yellow',
              debug: 'blue',
              error: 'red'
            };
          },

          "b9d463a910d4790add82d228e56200d0": // from: node_modules/testify/src/context.coffee
          function(exports, require, module, __filename, __dirname) {
            var Context, EventEmitter, FSM,
            __slice = [].slice;

            EventEmitter = require("events").EventEmitter;

            FSM = require("./minfinite");

            module.exports = Context = (function() {

              Context.prototype.on = function() {
                var args, _ref;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return (_ref = this.emitter).on.apply(_ref, args);
              };

              Context.prototype.once = function() {
                var args, _ref;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return (_ref = this.emitter).once.apply(_ref, args);
              };

              function Context(name, work, parent) {
                var _this = this;
                this.name = name;
                this.work = work;
                this.parent = parent;
                if (this.work.length === 0) {
                  this.type = "sync";
                } else {
                  this.type = "async";
                }
                if (this.parent) {
                  this.level = this.parent.level + 1;
                } else {
                  this.level = 0;
                }
                this.children = [];
                this.emitter = new EventEmitter();
                this.fsm = new FSM();
                this.fsm.emitter.once("COMPLETE", function() {
                  return _this.emitter.emit("done");
                });
                this.fsm.define({
                  START: {
                    sync_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "SYNC"
                    },
                    async_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "ASYNC"
                    },
                    childless: {
                      action: function() {},
                      next: "CHILDLESS"
                    },
                    completion: {
                      action: function() {
                        return _this.notify_parent();
                      },
                      next: "COMPLETE"
                    },
                    end_of_block: {
                      action: function() {
                        return _this.notify_parent();
                      },
                      next: "COMPLETE"
                    }
                  },
                  SYNC: {
                    sync_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "SYNC"
                    },
                    async_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "ASYNC"
                    },
                    end_of_block: {
                      action: function() {
                        return _this.notify_parent();
                      },
                      next: "COMPLETE"
                    },
                    completion: {
                      action: function() {
                        return _this.notify_parent();
                      },
                      next: "COMPLETE"
                    }
                  },
                  ASYNC: {
                    sync_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "ASYNC"
                    },
                    async_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "ASYNC"
                    },
                    end_of_block: {
                      action: function() {},
                      next: "ASYNC"
                    },
                    completion: {
                      action: function() {
                        return _this.notify_parent();
                      },
                      next: "COMPLETE"
                    }
                  },
                  CHILDLESS: {
                    sync_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "SYNC"
                    },
                    async_child: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "ASYNC"
                    },
                    completion: {
                      action: function() {
                        return _this.notify_parent();
                      },
                      next: "COMPLETE"
                    }
                  },
                  COMPLETE: {
                    completion: {
                      action: function() {
                        var args;
                        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      },
                      next: "COMPLETE"
                    },
                    reset: {
                      action: function() {},
                      next: "START"
                    },
                    end_of_block: {
                      action: function() {},
                      next: "COMPLETE"
                    }
                  }
                });
              }

              Context.prototype.state = function() {
                return this.fsm.state;
              };

              Context.prototype.event = function() {
                var args, name, _ref;
                name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                return (_ref = this.fsm).event.apply(_ref, [name].concat(__slice.call(args)));
              };

              Context.prototype.is_done = function() {
                return this.children.every(function(child) {
                  return child.state() === "COMPLETE";
                });
              };

              Context.prototype.notify_parent = function() {
                var _this = this;
                return setTimeout((function() {
                  var _ref, _ref1;
                  if ((_ref = _this.parent) != null ? _ref.is_done() : void 0) {
                    return (_ref1 = _this.parent) != null ? _ref1.event("completion", _this) : void 0;
                  }
                }), 0);
              };

              Context.prototype.done = function() {
                return this.event("completion");
              };

              Context.prototype.child = function(description, work) {
                var child;
                child = new this.constructor(description, work, this);
                if (child.type === "sync") {
                  this.event("sync_child", child);
                } else if (child.type === "async") {
                  this.event("async_child", child);
                } else {
                  throw new Error("bad type: " + child.type);
                }
                this.children.push(child);
                this.emitter.emit("child", child);
                child._run();
                return child;
              };

              Context.prototype._run = function() {
                var args;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                this.work(this);
                if (this.type === "sync" || this.children.length > 0) {
                  return this.event("end_of_block");
                } else {
                  return this.event("childless");
                }
              };

              return Context;

            })();

          },

          "4aaff567286b962812b471b15e32f666": // from: node_modules/testify/src/minfinite.coffee
          function(exports, require, module, __filename, __dirname) {
            var EventEmitter, FSM,
            __slice = [].slice;

            EventEmitter = require("events").EventEmitter;

            module.exports = FSM = (function() {

              function FSM(initial_state) {
                if (initial_state == null) {
                  initial_state = "START";
                }
                this.state = initial_state;
                this.emitter = new EventEmitter();
              }

              FSM.prototype.define = function(table) {
                if (this.validate(table)) {
                  return this.table = table;
                } else {
                  throw new Error("Invalid state table");
                }
              };

              FSM.prototype.validate = function(table) {
                var action, def, event, next, state, transition;
                for (state in table) {
                  def = table[state];
                  if (!(Object.keys(def).length > 0)) {
                    return false;
                  }
                  for (event in def) {
                    transition = def[event];
                    action = transition.action, next = transition.next;
                    if (typeof action !== "function") {
                      console.log("Action for " + state + ", " + event + " is not a function");
                      return false;
                    }
                    if (typeof next !== "string") {
                      console.log("Next state for " + state + ", " + event + " is not a string");
                      return false;
                    }
                    if (!table[next]) {
                      console.log("Next state for " + state + ", " + event + " does not exist");
                      return false;
                    }
                  }
                }
                return true;
              };

              FSM.prototype.event = function() {
                var action, args, current_state, error, name, next, transition;
                name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                current_state = this.state;
                transition = this.table[this.state][name];
                if (!transition) {
                  error = new Error("State(" + this.state + ") has no transition for Event(" + name + ")");
                  error.state = this.state;
                  error.event = name;
                  throw error;
                } else {
                  action = transition.action, next = transition.next;
                  action.apply(null, args);
                  this.state = next;
                  if (this.state !== current_state) {
                    return this.emitter.emit(this.state);
                  }
                }
              };

              return FSM;

            })();

          },

          "9b447f645747120b1ce9c0bf912d60e2": // from: node_modules/testify/src/reporters.coffee
          function(exports, require, module, __filename, __dirname) {
            var ConsoleReporter, DOMReporter;

            ConsoleReporter = (function() {

              function ConsoleReporter(_arg) {
                this.color = _arg.color;
              }

              ConsoleReporter.prototype.add_suite = function(suite) {
                var _this = this;
                suite.emitter.on("child", function(child) {
                  return _this.hook(child);
                });
                suite.fsm.emitter.on("COMPLETE", function() {
                  return process.nextTick((function() {
                    return _this.report_suite(suite);
                  }));
                });
                return process.on("exit", function() {
                  return _this.report_suite(suite);
                });
              };

              ConsoleReporter.prototype.hook = function(child) {
                var _this = this;
                child.emitter.on("child", function(context) {
                  return _this.hook(context);
                });
                return child.emitter.on("status", function(status) {
                  return _this.status(status);
                });
              };

              ConsoleReporter.prototype.status = function(type) {
                var abbrev;
                if (abbrev = this.abbreviation[type]) {
                  return process.stdout.write(this.colorize(type, abbrev));
                }
              };

              ConsoleReporter.prototype.abbreviation = {
                pass: ".",
                incomplete: "I",
                failure: "F",
                error: "E"
              };

              ConsoleReporter.prototype.report_suite = function(suite) {
                var counts, level, result, summary, test, _i, _len;
                if (suite._reported) {
                  return;
                } else {
                  suite._reported = true;
                }
                if (suite.failed) {
                  suite.name = "" + suite.name + " (FAILED)";
                } else {
                  suite.name = "" + suite.name + " (PASSED)";
                }
                result = [];
                counts = {
                  passed: 0,
                  failed: 0,
                  errored: 0,
                  incomplete: 0
                };
                this.collect(suite, result);
                for (_i = 0, _len = result.length; _i < _len; _i++) {
                  test = result[_i];
                  level = test.level;
                  if (test.state() !== "COMPLETE") {
                    this.result("" + test.name + " ( incomplete )", {
                      type: "incomplete",
                      level: level
                    });
                    counts.incomplete++;
                  } else if (test.failed === false) {
                    this.result(test.name, {
                      type: "pass",
                      level: level
                    });
                    counts.passed++;
                  } else if (test.failed.constructor === String || test.failed.name === "AssertionError") {
                    this.result("" + test.name + " ( " + (test.failed.toString()) + " )", {
                      type: "failure",
                      level: level,
                      stack: test.failed.stack
                    });
                    counts.failed++;
                  } else {
                    this.result("" + test.name + " ( " + (test.failed.toString()) + " )", {
                      type: "error",
                      level: level,
                      stack: test.failed.stack
                    });
                    counts.errored++;
                  }
                }
                summary = [this.colorize("pass", "Passed: " + counts.passed)];
                if (counts.failed > 0) {
                  summary.push(this.colorize("failure", "Failed: " + counts.failed));
                }
                if (counts.errored > 0) {
                  summary.push(this.colorize("error", "Errored: " + counts.errored));
                }
                if (counts.incomplete > 0) {
                  summary.push(this.colorize("incomplete", "Incomplete: " + counts.errored));
                }
                console.log();
                console.log(summary.join("    "));
                if (suite.failed && process.exit) {
                  return process.exit(1);
                }
              };

              ConsoleReporter.prototype.collect = function(context, array) {
                var item, _i, _len, _ref, _results;
                if (array == null) {
                  array = [];
                }
                array.push(context);
                _ref = context.children;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  item = _ref[_i];
                  _results.push(this.collect(item, array));
                }
                return _results;
              };

              ConsoleReporter.prototype.result = function(string, options) {
                var level, match, regex, space, where;
                if (options == null) {
                  options = {};
                }
                if (!this._receiving_results) {
                  console.log();
                  this._receiving_results = true;
                }
                if (options.type) {
                  string = this.colorize(options.type, string);
                }
                space = "";
                if (level = options.level) {
                  while (level--) {
                    space = space + "    ";
                  }
                  string = space + string;
                }
                console.log(string);
                if (options.stack) {
                  where = options.stack.split("\n")[1];
                  regex = /\((.*)\)/;
                  match = regex.exec(where);
                  try {
                    return console.log(space + match[1]);
                  } catch (error) {
                    return console.log(space + where.slice(7));
                  }
                }
              };

              ConsoleReporter.prototype.colorize = function(type, string) {
                var color;
                if (this.color && (color = this.color_map[type])) {
                  return string[color];
                } else {
                  return string;
                }
              };

              ConsoleReporter.prototype.color_map = {
                pass: "green",
                incomplete: "magenta",
                failure: "red",
                error: "yellow"
              };

              return ConsoleReporter;

            })();

            DOMReporter = (function() {

              function DOMReporter(id, options) {
                if (options == null) {
                  options = {};
                }
                this.timeout = options.timeout || 2000;
                this.root = document.getElementById(id);
                this.suites = [];
              }

              DOMReporter.prototype.add_suite = function(suite) {
                var _this = this;
                this.suite_dom(suite);
                suite.emitter.on("child", function(child) {
                  return _this.handle_child(suite, child);
                });
                suite.fsm.emitter.on("COMPLETE", function() {
                  return _this.report_suite(suite);
                });
                return setTimeout((function() {
                  return _this.report_suite(suite);
                }), this.timeout);
              };

              DOMReporter.prototype.handle_child = function(suite, child) {
                var _this = this;
                this.test_dom(child);
                child.emitter.on("child", function(context) {
                  return _this.handle_child(suite, context);
                });
                return child.emitter.on("status", function(status) {
                  return _this.status(suite, child, status);
                });
              };

              DOMReporter.prototype.report_suite = function(suite) {
                var level, test, tests, _i, _j, _len, _len1, _ref, _results;
                if (suite._reported) {
                  return;
                } else {
                  suite._reported = true;
                }
                if (suite.state() !== "COMPLETE") {
                  suite._html.title.classList.add("incomplete");
                } else if (suite.failed === false) {
                  suite._html.title.classList.add("pass");
                } else {
                  suite._html.title.classList.add("failed");
                }
                tests = [];
                _ref = suite.children;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  test = _ref[_i];
                  this.collect(test, tests);
                }
                _results = [];
                for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
                  test = tests[_j];
                  level = test.level;
                  if (test.state() !== "COMPLETE") {
                    _results.push(this.result(test, {
                      type: "incomplete"
                    }));
                  } else if (test.failed === false) {
                    _results.push(this.result(test, {
                      type: "pass"
                    }));
                  } else if (test.failed.constructor === String || test.failed.name === "AssertionError") {
                    _results.push(this.result(test, {
                      type: "failure",
                      stack: test.failed.stack
                    }));
                  } else {
                    _results.push(this.result(test, {
                      type: "error",
                      stack: test.failed.stack
                    }));
                  }
                }
                return _results;
              };

              DOMReporter.prototype.collect = function(context, array) {
                var item, _i, _len, _ref;
                if (array == null) {
                  array = [];
                }
                array.push(context);
                _ref = context.children;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  item = _ref[_i];
                  this.collect(item, array);
                }
                return array;
              };

              DOMReporter.prototype.suite_dom = function(suite) {
                var main, tests, title, _ref;
                suite._html = {
                  main: document.createElement("div"),
                  title: document.createElement("h3"),
                  tests: document.createElement("ul")
                };
                _ref = suite._html, main = _ref.main, tests = _ref.tests, title = _ref.title;
                main.classList.add("testify_suite");
                title.textContent = suite.name;
                main.appendChild(title);
                main.appendChild(tests);
                return this.root.appendChild(main);
              };

              DOMReporter.prototype.test_dom = function(test) {
                var span, tests;
                test._html = {
                  name: document.createElement("li")
                };
                test._html.name.classList.add("testify_test");
                span = document.createElement("span");
                span.classList.add("testify_test_name");
                span.textContent = test.name;
                test._html.name.appendChild(span);
                if (test.parent._html.tests) {

                } else {
                  tests = test.parent._html.tests = document.createElement("ul");
                  test.parent._html.name.appendChild(tests);
                }
                return test.parent._html.tests.appendChild(test._html.name);
              };

              DOMReporter.prototype.status = function(suite, test, type) {
                var fn,
                _this = this;
                fn = function() {
                  var element, match, regex, span, stacky, where;
                  element = test._html.name;
                  span = element.children[0];
                  span.classList.add(type);
                  if (type === "failure" || type === "error") {
                    span.textContent = span.textContent + (" (" + (test.failed.toString()) + ")");
                    stacky = document.createElement("pre");
                    where = test.failed.stack.split("\n")[1];
                    regex = /\((.*)\)/;
                    match = regex.exec(where);
                    try {
                      stacky.textContent = match[1];
                    } catch (error) {
                      stacky.textContent = where.slice(7);
                    }
                    stacky.classList.add("stack");
                    return element.insertBefore(stacky, span.nextSibling);
                  } else if (type === "incomplete") {
                    return span.textContent = span.textContent + " (incomplete)";
                  }
                };
                return setTimeout(fn, 50);
              };

              DOMReporter.prototype.result = function(test, options) {
                var element, span, type_string;
                if (test.children.length > 0 || options.type === "incomplete") {
                  element = test._html.name;
                  if (options.type) {
                    span = element.children[0];
                    span.classList.add(options.type);
                    type_string = " (" + options.type + ")";
                    if (options.type === "failure") {
                      return span.textContent = span.textContent + (" (" + (test.failed.toString()) + ")");
                    } else if (options.type === "incomplete") {
                      return span.textContent = span.textContent + " (incomplete)";
                    }
                  }
                }
              };

              return DOMReporter;

            })();

            module.exports = {
              ConsoleReporter: ConsoleReporter,
              DOMReporter: DOMReporter
            };

          },

          "d9f643967b824a7805227d7fccafdc0e": // from: node_modules/testify/src/test.coffee
          function(exports, require, module, __filename, __dirname) {
            var Context, TestContext, colors,
            __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              },
              __slice = [].slice;

            colors = require("colors");

            Context = require("./context");

            module.exports = TestContext = (function(_super) {

              __extends(TestContext, _super);

              function TestContext() {
                var args;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                TestContext.__super__.constructor.apply(this, args);
                this.failed = false;
              }

              TestContext.prototype.test = function(description, work) {
                return this.child(description, work);
              };

              TestContext.prototype.run = function() {
                TestContext.reporter.add_suite(this);
                return this._run();
              };

              TestContext.prototype._run = function() {
                var args;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                this.work(this);
                if (this.type === "sync" || this.children.length > 0) {
                  return this.event("end_of_block");
                } else {
                  return this.event("childless");
                }
              };

              TestContext.prototype._run = function() {
                var _this = this;
                this.fsm.emitter.once("COMPLETE", function() {
                  if (_this.timeout_id) {
                    clearTimeout(_this.timeout_id);
                  }
                  return _this.timeout_id = void 0;
                });
                try {
                  if (!this.failed) {
                    this.work(this);
                  }
                  if (this.type === "sync" || this.children.length > 0) {
                    this.event("end_of_block");
                    return this.status("pass", ".");
                  } else {
                    if (!this.failed) {
                      return this.event("childless");
                    }
                  }
                } catch (error) {
                  this.fail(error);
                  return this.event("end_of_block");
                }
              };

              TestContext.prototype.event = function() {
                var args, current, my_error;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                try {
                  current = this.fsm.state;
                  return TestContext.__super__.event.apply(this, args);
                } catch (error) {
                  if (error.state === "COMPLETE" && error.event === "async_child") {
                    my_error = new Error("Asynchronous test created after parent had completed");
                    my_error.stack = error.stack.split("\n").slice(5).join("\n");
                    return args[1].fail(my_error);
                  } else if (error.state === "COMPLETE" && error.event === "sync_child") {
                    my_error = new Error("Synchronous test created after parent had completed");
                    my_error.stack = error.stack.split("\n").slice(5).join("\n");
                    return args[1].fail(my_error);
                  } else {
                    throw error;
                  }
                }
              };

              TestContext.prototype.status = function(type) {
                return this.emitter.emit("status", type);
              };

              TestContext.prototype.pass = function() {
                if (!this.failed) {
                  this.status("pass");
                  return this.done();
                }
              };

              TestContext.prototype.fail = function(error) {
                var message, throwaway;
                if (error.constructor === String) {
                  this.status("failure");
                  throwaway = new Error(error);
                  message = error.toString();
                  error = {
                    name: "AssertionError",
                    stack: throwaway.stack.split("\n").slice(1).join("\n"),
                    toString: function() {
                      return message;
                    }
                  };
                } else if (error.name === "AssertionError") {
                  this.status("failure");
                } else {
                  this.status("error");
                }
                if (this.type === "async") {
                  this.event("completion");
                }
                return this.propagate_failure(error);
              };

              TestContext.prototype.timeout = function(milliseconds, message) {
                var fn,
                _this = this;
                fn = function() {
                  return _this.fail(message || ("Timed out after " + milliseconds + " milliseconds"));
                };
                return this.timeout_id = setTimeout(fn, milliseconds);
              };

              TestContext.prototype.propagate_failure = function(error) {
                var _ref;
                this.failed = error;
                return (_ref = this.parent) != null ? _ref.propagate_failure("subtest failures") : void 0;
              };

              return TestContext;

            })(Context);

          },

          "fd4a31413497930ab9f29b0a7dfb92e6": // from: node_modules/testify/src/testify.coffee
          function(exports, require, module, __filename, __dirname) {
            var EventEmitter, TestContext, Testify,
            __slice = [].slice;

            EventEmitter = require("events").EventEmitter;

            TestContext = require("./test");

            Testify = {
              Context: require("./context"),
              ConsoleReporter: require("./reporters").ConsoleReporter,
              DOMReporter: require("./reporters").DOMReporter,
              TestContext: TestContext,
              count: 0,
              emitter: new EventEmitter(),
              once: function() {
                var args, _ref;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return (_ref = Testify.emitter).once.apply(_ref, args);
              },
              options: {
                color: true
              },
              test: function(name, fn) {
                var suite;
                TestContext.options = Testify.options;
                TestContext.reporter = Testify.reporter || new Testify.ConsoleReporter(Testify.options);
                suite = new TestContext(name, fn);
                Testify.count++;
                suite.fsm.emitter.once("COMPLETE", function() {
                  Testify.count--;
                  if (Testify.count === 0) {
                    return Testify.emitter.emit("done");
                  }
                });
                suite.run();
                return suite;
              }
            };

            module.exports = Testify;

          },

          "2bf3ec58ffdc0343a3db891c23d618e4": // from: node_modules/patchboard-js/node_modules/fairmont/index.coffee
          function(exports, require, module, __filename, __dirname) {
            var $, Crypto, classToType, include, name, w, _i, _len, _ref,
            __slice = [].slice;

            $ = {};

            $.w = w = function(string) {
              return string.trim().split(/\s+/);
            };

            $.capitalize = function(string) {
              return string[0].toUpperCase() + string.slice(1);
            };

            $.titleCase = function(string) {
              return string.toLowerCase().replace(/^(\w)|\W(\w)/g, function(char) {
                return char.toUpperCase();
              });
            };

            $.camelCase = function(string) {
              return string.toLowerCase().replace(/(\W+\w)/g, function(string) {
                return string.trim().toUpperCase();
              });
            };

            $.underscored = function(string) {
              return $.plainText(string).replace(/\W+/g, "_");
            };

            $.dashed = function(string) {
              return $.plainText(string).replace(/\W+/g, "-");
            };

            $.plainText = function(string) {
              return string.replace(/^[A-Z]/g, function(c) {
                return c.toLowerCase();
              }).replace(/[A-Z]/g, function(c) {
                return " " + (c.toLowerCase());
              }).replace(/\W+/g, " ");
            };

            $.htmlEscape = (function() {
              var entities, map, re;
              map = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': '&quot;',
                "'": '&#39;',
                "/": '&#x2F;'
              };
              entities = Object.keys(map);
              re = new RegExp("" + (entities.join('|')), "g");
              return function(string) {
                return string.replace(re, function(s) {
                  return map[s];
                });
              };
            })();

            classToType = new Object;

            _ref = w("Boolean Number String Function Array Date RegExp");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              name = _ref[_i];
              classToType["[object " + name + "]"] = name.toLowerCase();
            }

            $.type = function(object) {
              var myClass;
              if (object === void 0) {
                return "undefined";
              }
              if (object === null) {
                return "null";
              }
              myClass = Object.prototype.toString.call(object);
              if (myClass in classToType) {
                return classToType[myClass];
              } else {
                return "object";
              }
            };

            $.remove = function(array, element) {
              var index, _ref1;
              if ((index = array.indexOf(element)) > -1) {
                [].splice.apply(array, [index, index - index + 1].concat(_ref1 = [])), _ref1;
                return element;
              } else {
                return null;
              }
            };

            $.uniq = function(array, hash) {
              var element, key, uniques, _j, _k, _len1, _len2, _ref1, _results;
              if (hash == null) {
                hash = function(object) {
                  return object.toString();
                };
              }
              uniques = {};
              for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
                element = array[_j];
                uniques[hash(element)] = element;
              }
              _ref1 = Object.keys(uniques);
              _results = [];
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                key = _ref1[_k];
                _results.push(uniques[key]);
              }
              return _results;
            };

            $.to = function(to, from) {
              if (from instanceof to) {
                return from;
              } else {
                return new to(from);
              }
            };

            $.exists = function(path) {
              var FileSystem;
              FileSystem = require("fs");
              return FileSystem.existsSync(path);
            };

            $.read = function(path) {
              var FileSystem;
              FileSystem = require("fs");
              return FileSystem.readFileSync(path, 'utf-8');
            };

            $.readdir = function(path) {
              var FileSystem;
              FileSystem = require("fs");
              return FileSystem.readdirSync(path);
            };

            $.stat = function(path) {
              var FileSystem;
              FileSystem = require("fs");
              return FileSystem.statSync(path);
            };

            $.write = function(path, content) {
              var FileSystem;
              FileSystem = require("fs");
              return FileSystem.writeFileSync(path, content);
            };

            $.chdir = function(dir, fn) {
              var cwd, rval;
              cwd = process.cwd();
              process.chdir(dir);
              rval = fn();
              process.chdir(cwd);
              return rval;
            };

            $.rm = function(path) {
              var FileSystem;
              FileSystem = require("fs");
              return FileSystem.unlinkSync(path);
            };

            $.rmdir = function(path) {
              var FileSystem;
              FileSystem = require("fs");
              return FileSystem.rmdirSync(path);
            };

            Crypto = require("crypto");

            $.md5 = function(string) {
              return Crypto.createHash('md5').update(string, 'utf-8').digest("hex");
            };

            $.base64 = function(string) {
              return new Buffer(string).toString('base64');
            };

            $.include = include = function() {
              var key, mixin, mixins, object, value, _j, _len1;
              object = arguments[0], mixins = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
              for (_j = 0, _len1 = mixins.length; _j < _len1; _j++) {
                mixin = mixins[_j];
                for (key in mixin) {
                  value = mixin[key];
                  object[key] = value;
                }
              }
              return object;
            };

            $.Property = {
              property: (function() {
                var defaults;
                defaults = {
                  enumerable: true,
                  configurable: true
                };
                return function(properties) {
                  var key, value, _results;
                  _results = [];
                  for (key in properties) {
                    value = properties[key];
                    include(value, defaults);
                    _results.push(Object.defineProperty(this.prototype, key, value));
                  }
                  return _results;
                };
              })()
            };

            $.merge = function() {
              var destination, k, object, objects, v, _j, _len1;
              objects = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              destination = {};
              for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
                object = objects[_j];
                for (k in object) {
                  v = object[k];
                  destination[k] = v;
                }
              }
              return destination;
            };

            $.delegate = function(from, to) {
              var value, _results;
              _results = [];
              for (name in to) {
                value = to[name];
                if (($.type(value)) === "function") {
                  _results.push((function(value) {
                    return from[name] = function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      return value.call.apply(value, [to].concat(__slice.call(args)));
                    };
                  })(value));
                }
              }
              return _results;
            };

            $.abort = function() {
              return process.exit(-1);
            };

            $.memoize = function(fn, hash) {
              var memo;
              if (hash == null) {
                hash = function(object) {
                  return object.toString();
                };
              }
              memo = {};
              return function(thing) {
                var _name, _ref1;
                return (_ref1 = memo[_name = hash(thing)]) != null ? _ref1 : memo[_name] = fn(thing);
              };
            };

            $.timer = function(wait, action) {
              var id;
              id = setTimeout(action, wait);
              return function() {
                return clearTimeout(id);
              };
            };

            module.exports = $;

          },

          "81951198ddb3737232107a27beaf8d5f": // from: node_modules/patchboard-js/node_modules/fairmont/test.coffee
          function(exports, require, module, __filename, __dirname) {
            var Testify, assert;

            assert = require("assert");

            Testify = require("testify");

            Testify.test("String functions", function(context) {
              context.test("capitalize", function() {
                var capitalize;
                capitalize = require("./index").capitalize;
                return assert.equal(capitalize("hello world"), "Hello world");
              });
              context.test("titleCase", function() {
                var titleCase;
                titleCase = require("./index").titleCase;
                return assert.equal(titleCase("hello woRld"), "Hello World");
              });
              context.test("underscored", function() {
                var underscored;
                underscored = require("./index").underscored;
                return assert.equal(underscored("Hello World"), "hello_world");
              });
              context.test("camelCase", function() {
                var camelCase;
                camelCase = require("./index").camelCase;
                return assert.equal(camelCase("Hello World"), "helloWorld");
              });
              context.test("dashed", function() {
                var dashed;
                dashed = require("./index").dashed;
                return assert.equal(dashed("Hello World"), "hello-world");
              });
              context.test("plainText", function() {
                var plainText;
                plainText = require("./index").plainText;
                assert.equal(plainText("hello-world"), "hello world");
                return assert.equal(plainText("Hello World"), "hello world");
              });
              return context.test("htmlEscape", function() {
                var htmlEscape;
                htmlEscape = require("./index").htmlEscape;
                return assert.equal(htmlEscape("<a href='foo'>bar & baz</a>"), "&lt;a href=&#39;foo&#39;&gt;bar &amp; baz&lt;&#x2F;a&gt;");
              });
            });

          },

          "96d25db5f5df90904def9af7ec186d37": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3/arrays.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            module.exports = {
              maxItems: function(value, context) {
                var _this = this;
                return function(data) {
                  if (_this.test_type("array", data)) {
                    return data.length <= value;
                  } else {
                    return true;
                  }
                };
              },
              minItems: function(value, context) {
                var _this = this;
                return function(data) {
                  if (_this.test_type("array", data)) {
                    return data.length >= value;
                  } else {
                    return true;
                  }
                };
              },
              uniqueItems: function(definition, context) {
                var _this = this;
                return function(data) {
                  console.error("uniqueItems is a no-op because I'm protecting you from the Cartesian product");
                  return true;
                };
              },
              items: function(definition, context) {
                var add_item_test, additionalItems, i, schema, test, tests, _i, _len,
                _this = this;
                additionalItems = context.modifiers.additionalItems;
                if (this.test_type("array", definition)) {
                  if (additionalItems != null) {
                    if (this.test_type("object", additionalItems)) {
                      add_item_test = this.compile(additionalItems, context);
                    } else if (additionalItems === false) {
                      add_item_test = function() {
                        return false;
                      };
                    } else {
                      throw new Error("The 'additionalItems' attribute must be an object or false");
                    }
                  } else {
                    add_item_test = null;
                  }
                  tests = [];
                  for (i = _i = 0, _len = definition.length; _i < _len; i = ++_i) {
                    schema = definition[i];
                    tests.push(this.compile(schema, context.child(i.toString())));
                  }
                  return function(data) {
                    var item, test, _j, _k, _len1, _len2, _ref;
                    if (!_this.test_type("array", data)) {
                      return true;
                    } else {
                      for (i = _j = 0, _len1 = tests.length; _j < _len1; i = ++_j) {
                        test = tests[i];
                        if (!test(data[i])) {
                          return false;
                        }
                      }
                      if ((data.length > tests.length) && add_item_test) {
                        _ref = data.slice(tests.length);
                        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                          item = _ref[_k];
                          if (!add_item_test(item)) {
                            return false;
                          }
                        }
                      }
                      return true;
                    }
                  };
                } else {
                  test = this.compile(definition, context);
                  return function(data) {
                    var item, _j, _len1;
                    for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
                      item = data[_j];
                      if (!test(item)) {
                        return false;
                      }
                    }
                    return true;
                  };
                }
              }
            };

          },

          "bc5b865c7d167783d0dc7f60f7339e07": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3/attributes.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            module.exports = {
              $schema: {
                ignore: true
              },
              id: {
                ignore: true
              },
              $ref: {
                ignore: true
              },
              "extends": {
                ignore: true
              },
              "default": {
                ignore: true
              },
              type: {},
              "enum": {},
              disallow: {},
              properties: {},
              required: {
                ignore: true
              },
              dependencies: {},
              patternProperties: {},
              additionalProperties: {
                modifiers: ["properties", "patternProperties"]
              },
              items: {
                modifiers: ["additionalItems"]
              },
              additionalItems: {
                ignore: true
              },
              maxItems: {},
              minItems: {},
              uniqueItems: {},
              minimum: {
                modifiers: ["exclusiveMinimum"]
              },
              exclusiveMinimum: {
                ignore: true
              },
              maximum: {
                modifiers: ["exclusiveMaximum"]
              },
              exclusiveMaximum: {
                ignore: true
              },
              divisibleBy: {},
              maxLength: {},
              minLength: {},
              pattern: {},
              format: {}
            };

          },

          "ee771fc350e250678e29eca4848122bf": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3/comparison.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            module.exports = {
              "enum": function(values, context) {
                var _this = this;
                if (this.test_type("array", values)) {
                  return function(data) {
                    var value, _i, _len;
                    for (_i = 0, _len = values.length; _i < _len; _i++) {
                      value = values[_i];
                      if (_this.equal(data, value)) {
                        return true;
                      }
                    }
                    return false;
                  };
                } else {
                  throw new Error("Value of 'enum' MUST be an Array");
                }
              },
              equal: function(got, want) {
                if (want instanceof Array) {
                  return this.array_equal(got, want);
                } else if (this.is_object(want)) {
                  return this.object_equal(got, want);
                } else {
                  return got === want;
                }
              },
              array_equal: function(got, want) {
                var i, item, _i, _len;
                if (!(got instanceof Array)) {
                  return false;
                }
                if (want.length === 0) {
                  return true;
                }
                if (got.length !== want.length) {
                  return false;
                }
                for (i = _i = 0, _len = want.length; _i < _len; i = ++_i) {
                  item = want[i];
                  if (!this.equal(got[i], item)) {
                    return false;
                  }
                }
                return true;
              },
              object_equal: function(got, want) {
                var key, value;
                if (!this.is_object(got)) {
                  return false;
                }
                if (Object.keys(got).length !== Object.keys(want).length) {
                  return false;
                }
                for (key in want) {
                  value = want[key];
                  if (!this.equal(got[key], value)) {
                    return false;
                  }
                }
                return true;
              }
            };

          },

          "e3d178a70062de42c511ad42d5183e16": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3/numeric.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            module.exports = {
              divisibleBy: function(value, context) {
                var _this = this;
                return function(data) {
                  if (_this.test_type("number", data)) {
                    return (data / value) % 1 === 0;
                  } else {
                    return true;
                  }
                };
              },
              minimum: function(value, _arg) {
                var exclusiveMinimum,
                _this = this;
                exclusiveMinimum = _arg.modifiers.exclusiveMinimum;
                if (exclusiveMinimum) {
                  return function(data) {
                    if (_this.test_type("number", data)) {
                      return data > value;
                    } else {
                      return true;
                    }
                  };
                } else {
                  return function(data) {
                    if (_this.test_type("number", data)) {
                      return data >= value;
                    } else {
                      return true;
                    }
                  };
                }
              },
              maximum: function(value, _arg) {
                var exclusiveMaximum,
                _this = this;
                exclusiveMaximum = _arg.modifiers.exclusiveMaximum;
                if (exclusiveMaximum) {
                  return function(data) {
                    if (_this.test_type("number", data)) {
                      return data < value;
                    } else {
                      return true;
                    }
                  };
                } else {
                  return function(data) {
                    if (_this.test_type("number", data)) {
                      return data <= value;
                    } else {
                      return true;
                    }
                  };
                }
              }
            };

          },

          "42f2a6591a00ad3978fe8498a25f6c38": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3/objects.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            module.exports = {
              dependencies: function(definition, context) {
                var dependency, fn, property, tests,
                _this = this;
                if (!this.test_type("object", definition)) {
                  throw new Error("Value of 'dependencies' must be an object");
                } else {
                  tests = [];
                  for (property in definition) {
                    dependency = definition[property];
                    if (this.test_type("string", dependency)) {
                      tests.push(function(data) {
                        if (data[property]) {
                          return data[dependency];
                        } else {
                          return true;
                        }
                      });
                    } else if (this.test_type("array", dependency)) {
                      tests.push(function(data) {
                        var item, _i, _len;
                        if (data[property]) {
                          for (_i = 0, _len = dependency.length; _i < _len; _i++) {
                            item = dependency[_i];
                            if (!data[item]) {
                              return false;
                            }
                          }
                        }
                        return true;
                      });
                    } else if (this.test_type("object", dependency)) {
                      fn = this.compile(dependency, context.child(property));
                      tests.push(function(data) {
                        if (data[property]) {
                          return fn(data);
                        } else {
                          return true;
                        }
                      });
                    } else {
                      throw new Error("Invalid dependency");
                    }
                  }
                }
                return function(data) {
                  var test, _i, _len;
                  if (!_this.test_type("object", data)) {
                    return true;
                  } else {
                    for (_i = 0, _len = tests.length; _i < _len; _i++) {
                      test = tests[_i];
                      if (!test(data)) {
                        return false;
                      }
                    }
                    return true;
                  }
                };
              },
              properties: function(definition, context) {
                var new_context, property, required, schema, test, tests,
                _this = this;
                if (!this.test_type("object", definition)) {
                  throw new Error("The 'properties' attribute must be an object");
                }
                tests = {};
                required = [];
                for (property in definition) {
                  schema = definition[property];
                  new_context = context.child(property);
                  test = this.compile(schema, new_context);
                  tests[property] = test;
                  if (schema.required === true) {
                    required.push(property);
                  }
                }
                return function(data) {
                  var key, value, _i, _len;
                  if (!_this.test_type("object", data)) {
                    return true;
                  } else {
                    for (property in data) {
                      value = data[property];
                      if (test = tests[property]) {
                        if (!test(value)) {
                          return false;
                        }
                      }
                    }
                    for (_i = 0, _len = required.length; _i < _len; _i++) {
                      key = required[_i];
                      if (data[key] === void 0) {
                        return false;
                      }
                    }
                    return true;
                  }
                };
              },
              patternProperties: function(definition, context) {
                var pattern, schema, tests,
                _this = this;
                if (!this.test_type("object", definition)) {
                  throw new Error("The 'patternProperties' attribute must be an object");
                }
                tests = {};
                for (pattern in definition) {
                  schema = definition[pattern];
                  tests[pattern] = {
                    regex: new RegExp(pattern),
                    test: this.compile(schema, context.child(pattern))
                  };
                }
                return function(data) {
                  var object, property, value;
                  for (property in data) {
                    value = data[property];
                    for (pattern in tests) {
                      object = tests[pattern];
                      if (object.regex.test(property)) {
                        if (!object.test(value)) {
                          return false;
                        }
                      }
                    }
                  }
                  return true;
                };
              },
              additionalProperties: function(definition, context) {
                var add_prop_test, pattern, patternProperties, patterns, properties, schema, _ref,
                _this = this;
                _ref = context.modifiers, properties = _ref.properties, patternProperties = _ref.patternProperties;
                if (this.test_type("object", definition)) {
                  add_prop_test = this.compile(definition, context);
                } else if (definition === false) {
                  add_prop_test = function() {
                    return false;
                  };
                } else if (definition === void 0) {
                  add_prop_test = null;
                } else {
                  throw new Error("The 'additionalProperties' attribute must be an object or false");
                }
                patterns = {};
                for (pattern in patternProperties) {
                  schema = patternProperties[pattern];
                  patterns[pattern] = {
                    regex: new RegExp(pattern),
                    test: this.compile(schema, context.child(pattern))
                  };
                }
                return function(data) {
                  var explicit, object, patterned, property, value;
                  if (!_this.test_type("object", data)) {
                    return true;
                  } else {
                    for (property in data) {
                      value = data[property];
                      explicit = false;
                      patterned = false;
                      if (properties != null ? properties[property] : void 0) {
                        explicit = true;
                      } else {
                        if (patterns) {
                          for (pattern in patterns) {
                            object = patterns[pattern];
                            if (object.regex.test(property)) {
                              patterned = true;
                              if (!object.test(value)) {
                                return false;
                              }
                            }
                          }
                        }
                        if (!explicit && !patterned && add_prop_test) {
                          if (!add_prop_test(value)) {
                            return false;
                          }
                        }
                      }
                    }
                    return true;
                  }
                };
              }
            };

          },

          "5318c531e976adfee8cf77dd9110fe2e": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3/strings.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            var format_regexes;

            module.exports = {
              pattern: function(pattern, context) {
                var regex,
                _this = this;
                regex = new RegExp(pattern);
                return function(data) {
                  if (!_this.test_type("string", data)) {
                    return true;
                  } else {
                    return regex.test(data);
                  }
                };
              },
              minLength: function(value, context) {
                var _this = this;
                return function(data) {
                  if (!_this.test_type("string", data)) {
                    return true;
                  } else {
                    return data.length >= value;
                  }
                };
              },
              maxLength: function(value, context) {
                var _this = this;
                return function(data) {
                  if (!_this.test_type("string", data)) {
                    return true;
                  } else {
                    return data.length <= value;
                  }
                };
              },
              format: function(format_name, context) {
                var regex,
                _this = this;
                if (format_name === "regex") {
                  return function(data) {
                    var error;
                    if (!_this.test_type("string", data)) {
                      return true;
                    } else {
                      try {
                        new RegExp(data);
                        return true;
                      } catch (_error) {
                        error = _error;
                        return false;
                      }
                    }
                  };
                } else if (regex = format_regexes[format_name]) {
                  return (function(regex) {
                    return function(data) {
                      if (!_this.test_type("string", data)) {
                        return true;
                      } else {
                        return regex.test(data);
                      }
                    };
                  })(regex);
                } else {
                  throw new Error("Invalid format_name for 'format'");
                }
              }
            };

            format_regexes = {
              "date-time": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/,
              date: /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/,
              time: /^\d{2}:\d{2}:\d{2}$/,
              email: /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
              "ip-address": /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
              ipv6: /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
              uri: /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/,
              color: /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/,
              "host-name": /^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])$/,
              alpha: /^[a-zA-Z]+$/,
              alphanumeric: /^[a-zA-Z0-9]+$/,
              "utc-millisec": function(input) {
                return (typeof input === "string") && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
              },
              style: /\s*(.+?):\s*([^;]+);?/g,
              phone: /^\+(?:[0-9] ?){6,14}[0-9]$/
            };

          },

          "3477365edc59581475bbce22e45a815c": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3/type.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            module.exports = {
              type: function(definition, context) {
                var tests, type, _i, _len,
                _this = this;
                if (this.test_type("array", definition)) {
                  tests = [];
                  for (_i = 0, _len = definition.length; _i < _len; _i++) {
                    type = definition[_i];
                    tests.push(this.type(type, context));
                  }
                  return function(data) {
                    var test, _j, _len1;
                    for (_j = 0, _len1 = tests.length; _j < _len1; _j++) {
                      test = tests[_j];
                      if (test(data)) {
                        return true;
                      }
                    }
                    return false;
                  };
                } else if (this.test_type("object", definition)) {
                  return this.compile(definition, context);
                } else {
                  return function(data) {
                    return _this.test_type(definition, data);
                  };
                }
              },
              disallow: function(definition, context) {
                var tests, type,
                _this = this;
                if (this.test_type("array", definition)) {
                  tests = (function() {
                    var _i, _len, _results;
                    _results = [];
                    for (_i = 0, _len = definition.length; _i < _len; _i++) {
                      type = definition[_i];
                      _results.push(this.type(type, context));
                    }
                    return _results;
                  }).call(this);
                  return function(data) {
                    var test, _i, _len;
                    for (_i = 0, _len = tests.length; _i < _len; _i++) {
                      test = tests[_i];
                      if (test(data)) {
                        return false;
                      }
                    }
                    return true;
                  };
                } else {
                  return function(data) {
                    return !_this.test_type(definition, data);
                  };
                }
              },
              is_object: function(data) {
                return (data != null) && (typeof data) === "object" && !(data instanceof Array) && !(data instanceof Date);
              },
              test_type: function(type_name, data) {
                switch (type_name) {
                case "integer":
                  return typeof data === "number" && data % 1 === 0;
                case "number":
                  return typeof data === "number";
                case "string":
                  return typeof data === "string";
                case "object":
                  return this.is_object(data);
                case "array":
                  return data instanceof Array;
                case "boolean":
                  return typeof data === "boolean";
                case "null":
                  return data === null;
                case "any":
                  return true;
                default:
                  throw new Error("Bad type: '" + type_name + "'");
                }
              }
            };

          },

          "253726bca0a9048c21b9d9d2b7bbc10d": // from: node_modules/patchboard-js/node_modules/jsck/lib/draft3.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            var Context, URI, Validator, attributes, deap, escape,
            __slice = [].slice;

            URI = require("./uri");

            deap = require("deap");

            attributes = require("./draft3/attributes");

            escape = function(string) {
              return string.replace(/~0/g, "~").replace(/~1/g, "/").replace(/%25/g, "%");
            };

            Context = (function() {
              function Context(_arg) {
                this.pointer = _arg.pointer, this.scope = _arg.scope;
              }

              Context.prototype.child = function(token) {
                return new Context({
                  pointer: "" + this.pointer + "/" + token,
                  scope: this.scope
                });
              };

              return Context;

            })();

            module.exports = Validator = (function() {
              var m, method, module_name, modules, name, _i, _len;

              modules = ["type", "numeric", "comparison", "arrays", "objects", "strings"];

              for (_i = 0, _len = modules.length; _i < _len; _i++) {
                module_name = modules[_i];
                m = require("./draft3/" + module_name);
                for (name in m) {
                  method = m[name];
                  Validator.prototype[name] = method;
                }
              }

              function Validator() {
                var schema, schemas, _j, _len1;
                schemas = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                this.uris = {};
                this.media_types = {};
                this.unresolved = {};
                for (_j = 0, _len1 = schemas.length; _j < _len1; _j++) {
                  schema = schemas[_j];
                  this.add(schema);
                }
              }

              Validator.prototype.add = function(schema) {
                var context, found_schema, key, pointers, ref, scope, uri, _ref, _ref1;
                schema = deap.clone(schema);
                if (schema.id) {
                  schema.id = schema.id.replace(/#?$/, "#");
                }
                context = new Context({
                  pointer: schema.id || "#",
                  scope: schema.id || "#"
                });
                this.compile_references(schema, context);
                _ref = this.unresolved;
                for (ref in _ref) {
                  _ref1 = _ref[ref], scope = _ref1.scope, uri = _ref1.uri;
                  if (found_schema = this.resolve_ref(uri, scope)) {
                    delete this.unresolved[ref];
                    this.register(ref, found_schema);
                  }
                }
                if (Object.keys(this.unresolved).length > 0) {
                  pointers = (function() {
                    var _ref2, _results;
                    _ref2 = this.unresolved;
                    _results = [];
                    for (key in _ref2) {
                      uri = _ref2[key].uri;
                      _results.push(uri);
                    }
                    return _results;
                  }).call(this);
                  throw new Error("Unresolvable $ref values: " + (JSON.stringify(pointers)));
                }
                return this.compile(schema, context);
              };

              Validator.prototype.register = function(uri, schema) {
                var media_type;
                this.uris[uri] = schema;
                if (media_type = schema.mediaType) {
                  if (media_type !== "application/json") {
                    return this.media_types[media_type] = schema;
                  }
                }
              };

              Validator.prototype.validate = function(data) {
                return this.validator("#").validate(data);
              };

              Validator.prototype.validator = function(arg) {
                var schema,
                _this = this;
                if (schema = this.find(arg)) {
                  return {
                    validate: function(data) {
                      return {
                        valid: schema._test(data),
                        errors: ["Error report not implemented"]
                      };
                    },
                    toJSON: function() {
                      var args;
                      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      return schema;
                    }
                  };
                } else {
                  throw new Error("No schema found for '" + (JSON.stringify(arg)) + "'");
                }
              };

              Validator.prototype.find = function(arg) {
                var media_type, uri;
                if (this.test_type("string", arg)) {
                  uri = escape(arg);
                  return this.uris[uri];
                } else if (uri = arg.uri) {
                  uri = escape(uri);
                  return this.uris[uri];
                } else if (media_type = arg.mediaType) {
                  return this.media_types[media_type];
                } else {
                  return null;
                }
              };

              Validator.prototype.resolve_ref = function(uri, scope) {
                var schema;
                if (schema = this.find(uri)) {
                  if (schema.$ref) {
                    uri = URI.resolve(scope, schema.$ref);
                    return this.resolve_ref(uri);
                  } else {
                    return schema;
                  }
                } else {
                  return null;
                }
              };

              Validator.prototype.compile_references = function(schema, context) {
                var attribute, definition, new_context, pointer, scope, uri, _results;
                scope = context.scope, pointer = context.pointer;
                this.register(pointer, schema);
                if (schema.id && schema.id.indexOf("#") === 0) {
                  uri = URI.resolve(scope, schema.id);
                  schema.id = uri;
                  this.register(uri, schema);
                }
                if (this.test_type("object", schema)) {
                  _results = [];
                  for (attribute in schema) {
                    definition = schema[attribute];
                    new_context = context.child(attribute);
                    switch (attribute) {
                    case "$ref":
                      uri = URI.resolve(scope, definition);
                      if (pointer.indexOf(uri + "/") !== 0) {
                        schema.$ref = uri;
                        if (schema = this.resolve_ref(uri, scope)) {
                          _results.push(this.compile_references(schema, context));
                        } else {
                          _results.push(this.unresolved[pointer] = {
                            scope: context.scope,
                            uri: uri
                          });
                        }
                      } else {
                        _results.push(void 0);
                      }
                      break;
                    case "type":
                      if (this.test_type("array", definition)) {
                        _results.push(this.type_refs(definition, new_context));
                      } else {
                        _results.push(void 0);
                      }
                      break;
                    case "properties":
                    case "patternProperties":
                      _results.push(this.dictionary_refs(definition, new_context));
                      break;
                    case "items":
                      _results.push(this.items_refs(definition, new_context));
                      break;
                    case "additionalItems":
                    case "additionalProperties":
                    case "extends":
                      _results.push(this.compile_references(definition, context.child(attribute)));
                      break;
                    default:
                      if (!attributes[attribute] && this.test_type("object", definition)) {
                        _results.push(this.compile_references(definition, context.child(attribute)));
                      } else {
                        _results.push(void 0);
                      }
                    }
                  }
                  return _results;
                }
              };

              Validator.prototype.type_refs = function(union, context) {
                var i, schema, _j, _len1, _results;
                _results = [];
                for (i = _j = 0, _len1 = union.length; _j < _len1; i = ++_j) {
                  schema = union[i];
                  if (this.test_type("object", schema)) {
                    _results.push(this.compile_references(schema, context.child(i.toString())));
                  } else {
                    _results.push(void 0);
                  }
                }
                return _results;
              };

              Validator.prototype.dictionary_refs = function(properties, context) {
                var key, schema, _results;
                _results = [];
                for (key in properties) {
                  schema = properties[key];
                  _results.push(this.compile_references(schema, context.child(key)));
                }
                return _results;
              };

              Validator.prototype.items_refs = function(definition, context) {
                var def, i, _j, _len1, _results;
                if (this.test_type("array", definition)) {
                  _results = [];
                  for (i = _j = 0, _len1 = definition.length; _j < _len1; i = ++_j) {
                    def = definition[i];
                    _results.push(this.compile_references(def, context.child(i.toString())));
                  }
                  return _results;
                } else {
                  return this.compile_references(definition, context);
                }
              };

              Validator.prototype.compile = function(schema, context) {
                var attribute, definition, extended, key, new_context, pointer, ref, scope, spec, test, test_function, tests, uri, _j, _len1, _ref, _ref1, _ref2,
                _this = this;
                scope = context.scope, pointer = context.pointer;
                tests = [];
                if (uri = schema.$ref) {
                  uri = URI.resolve(scope, uri);
                  if (pointer.indexOf(uri) === 0) {
                    return this.recursive_test(schema, context);
                  }
                  schema = this.find(uri);
                  if (!schema) {
                    throw new Error("No schema found for $ref '" + uri + "'");
                  }
                }
                if (extended = schema["extends"]) {
                  if (ref = extended.$ref) {
                    uri = URI.resolve(scope, ref);
                    extended = this.find(uri);
                    if (!extended) {
                      throw new Error("No schema found for $ref '" + ref + "'");
                    }
                  }
                  delete schema["extends"];
                  if (this.test_type("array", extended)) {
                    deap.merge.apply(deap, [schema].concat(__slice.call(extended)));
                  } else {
                    deap.merge(schema, extended);
                  }
                }
                for (attribute in schema) {
                  definition = schema[attribute];
                  if (spec = attributes[attribute]) {
                    if (!spec.ignore) {
                      new_context = context.child(attribute);
                      new_context.modifiers = {};
                      if (spec.modifiers) {
                        _ref = spec.modifiers;
                        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                          key = _ref[_j];
                          new_context.modifiers[key] = schema[key];
                        }
                      }
                      test = this[attribute](definition, new_context);
                      test.pointer = new_context.pointer;
                      tests.push(test);
                    }
                  } else {
                    if (this.test_type("object", definition)) {
                      this.compile(definition, context.child(attribute));
                    }
                  }
                }
                test_function = function(data) {
                  var _k, _len2;
                  for (_k = 0, _len2 = tests.length; _k < _len2; _k++) {
                    test = tests[_k];
                    if (!test(data)) {
                      return false;
                    }
                  }
                  return true;
                };
                if (schema.id) {
                  uri = URI.resolve(scope, schema.id);
                  if ((_ref1 = this.find(uri)) != null) {
                    _ref1._test = test_function;
                  }
                }
                if ((_ref2 = this.find(pointer)) != null) {
                  _ref2._test = test_function;
                }
                return test_function;
              };

              Validator.prototype.recursive_test = function(schema, _arg) {
                var pointer, scope, uri,
                _this = this;
                scope = _arg.scope, pointer = _arg.pointer;
                uri = URI.resolve(scope, schema.$ref);
                if (schema = this.find(uri)) {
                  return function(data) {
                    return schema._test(data);
                  };
                } else {
                  throw new Error("No schema found for $ref '" + uri + "'");
                }
              };

              return Validator;

            })();

          },

          "3bb228a9f0315ca34fa56350046e7d89": // from: node_modules/patchboard-js/node_modules/jsck/lib/index.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            module.exports = {
              draft3: require("./draft3")
            };

          },

          "e04f7ebdcfb9b101cdeec3adcff8500c": // from: node_modules/patchboard-js/node_modules/jsck/lib/uri.js
          function(exports, require, module, __filename, __dirname) {
            // Generated by CoffeeScript 1.6.3
            var is_absolute, is_url, resolve;

            is_absolute = function(string) {
              return /^[\w\d+.-]+:/.test(string);
            };

            is_url = function(string) {
              return /^[\w\d+.-]+:\/\//.test(string);
            };

            resolve = function(scope, uri) {
              var main, _frag, _ref;
              if (is_absolute(uri)) {
                return uri;
              } else {
                scope = scope.replace(/#$/, "");
                if (uri.indexOf("#") === 0) {
                  _ref = scope.split("#"), main = _ref[0], _frag = _ref[1];
                  return main + uri;
                } else {
                  if (is_url(scope) || scope.indexOf("/") !== -1) {
                    return scope.replace(/\/[^/]+$/, "/" + uri);
                  } else {
                    return "" + scope + "/" + uri;
                  }
                }
              }
            };

            module.exports = {
              is_absolute: is_absolute,
              is_url: is_url,
              resolve: resolve
            };

          },

          "1e4cb2365e86975cee5a5b62560522f1": // from: node_modules/patchboard-js/node_modules/jsck/node_modules/deap/index.js
          function(exports, require, module, __filename, __dirname) {
            var lib = require('./lib/deap');

            var deap = module.exports = lib.extend;

            deap(deap, {
              clone: lib.clone,
              extend: lib.extend,
              update: lib.update,
              merge: lib.merge,
              extendShallow: lib.extendShallow,
              updateShallow: lib.updateShallow,
              mergeShallow: lib.mergeShallow
            });

          },

          "07382efae33f8db8150060f66241f3a1": // from: node_modules/patchboard-js/node_modules/jsck/node_modules/deap/lib/deap.js
          function(exports, require, module, __filename, __dirname) {
            var typeOf = require('./typeof'),
              slice = Array.prototype.slice;

            module.exports = {
              clone: clone,
              extend: deepExtend,
              extendShallow: extend,
              update: deepUpdate,
              updateShallow: update,
              merge: deepMerge,
              mergeShallow: merge
            };

            function clone(val) {
              switch (typeOf(val)) {
              case 'object':
                return deepExtend({}, val);
              case 'array':
                return val.map(clone);
              case 'date':
                return new Date(val.getTime());
              case 'regexp':
                return new RegExp(val);
              default:
                return val;
              }
            }

            function extend(a, b /*, [b2..n] */ ) {
              slice.call(arguments, 1).forEach(function(b) {
                Object.keys(b).forEach(function(p) {
                  a[p] = b[p];
                });
              });
              return a;
            }

            function deepExtend(a, b /*, [b2..n] */ ) {
              slice.call(arguments, 1).forEach(function(b) {
                Object.keys(b).forEach(function(p) {
                  if (typeOf(b[p]) === 'object' && typeOf(a[p]) === 'object') deepExtend(a[p], b[p]);
                  else a[p] = clone(b[p]);
                });
              });
              return a;
            }

            function update(a, b /*, [b2..n] */ ) {
              slice.call(arguments, 1).forEach(function(b) {
                Object.keys(b).forEach(function(p) {
                  if (a.hasOwnProperty(p)) a[p] = b[p];
                });
              });
              return a;
            }

            function deepUpdate(a, b /*, [b2..n] */ ) {
              slice.call(arguments, 1).forEach(function(b) {
                var ap, bp, ta, tb;
                Object.keys(b).forEach(function(p) {
                  if (a.hasOwnProperty(p)) {
                    ap = a[p];
                    bp = b[p];
                    ta = typeOf(ap);
                    tb = typeOf(bp);
                    if (tb === 'object' && ta === 'object') deepUpdate(ap, bp);
                    else if (tb === 'array' && ta === 'array') {
                      ap.length = 0;
                      ap.push.apply(ap, bp.map(clone));
                    } else a[p] = clone(bp);
                  }
                });
              });
              return a;
            }

            function merge(a, b /*, [b2..n] */ ) {
              slice.call(arguments, 1).forEach(function(b) {
                Object.keys(b).forEach(function(p) {
                  if (!a.hasOwnProperty(p)) a[p] = b[p];
                });
              });
              return a;
            }

            function deepMerge(a, b /*, [b2..n] */ ) {
              slice.call(arguments, 1).forEach(function(b) {
                var ap, bp, ta, tb;
                Object.keys(b).forEach(function(p) {
                  ap = a[p];
                  bp = b[p];
                  ta = typeOf(ap);
                  tb = typeOf(bp);
                  if (tb === 'object' && ta === 'object') deepMerge(ap, bp);
                  else if (!a.hasOwnProperty(p)) a[p] = clone(bp);
                });
              });
              return a;
            }

          },

          "e06990ed80036013bdbc22008581eb04": // from: node_modules/patchboard-js/node_modules/jsck/node_modules/deap/lib/typeof.js
          function(exports, require, module, __filename, __dirname) {

            module.exports = function(obj) {
              var t = typeof obj;
              if (t !== 'object') return t;

              // typeof null == 'object' so check seperately
              if (obj === null) return 'null';

              // typeof new Array|String|Number|Boolean|RegExp == 'object' so check seperately
              switch (obj.constructor) {
              case Array:
                return 'array';
              case String:
                return 'string';
              case Number:
                return 'number';
              case Boolean:
                return 'boolean';
              case RegExp:
                return 'regexp';
              case Date:
                return 'date';
              }
              return 'object';
            };

          },

          "12938380d91199c2a4e563439e5d0bec": // from: node_modules/patchboard-js/node_modules/jsck/node_modules/deap/shallow.js
          function(exports, require, module, __filename, __dirname) {
            var lib = require('./lib/deap');

            var deap = module.exports = lib.extendShallow;

            deap(deap, {
              clone: lib.clone,
              extend: lib.extendShallow,
              update: lib.updateShallow,
              merge: lib.mergeShallow
            });

          },

          "18afc51605ce5367f79707f21337f219": // from: node_modules/patchboard-js/src/action.coffee
          function(exports, require, module, __filename, __dirname) {
            var Action, Request, type,
            __slice = [].slice;

            Request = require("./request");

            type = require("fairmont").type;

            module.exports = Action = (function() {

              function Action(client, name, definition) {
                var request, response, _ref, _ref1;
                this.client = client;
                this.name = name;
                this.definition = definition;
                _ref = this.client, this.schema_manager = _ref.schema_manager, this.authorizer = _ref.authorizer, this.gzip = _ref.gzip;
                _ref1 = this.definition, request = _ref1.request, response = _ref1.response;
                this.status = (response != null ? response.status : void 0) || 200;
                if (request != null ? request.type : void 0) {
                  this.request_schema = this.schema_manager.find({
                    mediaType: request.type
                  });
                }
                if (response != null ? response.type : void 0) {
                  this.response_schema = this.schema_manager.find({
                    mediaType: response.type
                  });
                }
                this._base_headers = this.base_headers(this.definition);
              }

              Action.prototype.base_headers = function() {
                var headers;
                headers = {
                  "User-Agent": "patchboard-js"
                };
                if (this.request_schema) {
                  headers["Content-Type"] = this.request_schema.mediaType;
                }
                if (this.response_schema) {
                  headers["Accept"] = this.response_schema.mediaType;
                }
                return headers;
              };

              Action.prototype.create_request = function() {
                var args, auth_type, body, credential, key, options, request, resource, url, value, _ref;
                url = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                resource = this;
                options = this.process_args(args);
                request = {
                  url: url,
                  method: this.definition.method,
                  headers: {}
                };
                if (body = this.prepare_body(options)) {
                  request.body = body;
                }
                _ref = this._base_headers;
                for (key in _ref) {
                  value = _ref[key];
                  request.headers[key] = value;
                }
                if (auth_type = this.definition.authorization) {
                  credential = this.authorizer(auth_type, this.name);
                  request.headers["Authorization"] = "" + auth_type + " " + credential;
                }
                if (this.gzip) {
                  request.headers["Accept-Encoding"] = "gzip";
                }
                return request;
              };

              Action.prototype.request = function() {
                var args, callback, options, url, _i,
                _this = this;
                url = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
                if (!(callback != null)) {
                  callback = function(error, response) {
                    if (error) {
                      return console.error(error);
                    } else {
                      return console.log(response.body);
                    }
                  };
                }
                try {
                  options = this.create_request.apply(this, [url].concat(__slice.call(args)));
                } catch (error) {
                  if (typeof callback === "function") {
                    callback(error);
                  }
                  return;
                }
                return new Request(options, this.request_handler(callback));
              };

              Action.prototype.request_handler = function(callback) {
                var _this = this;
                return function(error, response) {
                  if (error) {
                    return callback(error);
                  } else if (response.status === _this.status) {
                    if (_this.response_schema) {
                      try {
                        response.data = JSON.parse(response.body);
                      } catch (error) {
                        callback("Unparseable response body: " + error.message);
                        return;
                      }
                      response.resource = _this.client.decorate(_this.response_schema, response.data);
                    }
                    return callback(null, response);
                  } else {
                    error = new Error("Unexpected response status: " + response.status);
                    error.status = response.status;
                    error.response = response;
                    return callback(error);
                  }
                };
              };

              Action.prototype.process_args = function(args) {
                var content_required, options, signature;
                options = {};
                signature = (args.map(function(arg) {
                  return type(arg);
                })).join(".");
                content_required = this.request_schema;
                if (content_required) {
                  switch (signature) {
                  case "string":
                    options.body = args[0];
                    break;
                  case "object":
                    options.content = args[0];
                    break;
                  case "array":
                    options.content = args[0];
                    break;
                  default:
                    throw new Error("Invalid arguments for action");
                  }
                } else {
                  switch (signature) {
                  case "":
                    args;
                    break;
                  default:
                    throw new Error("Invalid arguments for action");
                  }
                }
                return options;
              };

              Action.prototype.prepare_body = function(options) {
                if (options.content) {
                  return JSON.stringify(options.content);
                } else if (options.body) {
                  return options.body;
                } else {
                  return void 0;
                }
              };

              return Action;

            })();

          },

          "6057cd0902b262138421abb292e2b8af": // from: node_modules/patchboard-js/src/client.coffee
          function(exports, require, module, __filename, __dirname) {
            var Action, Client, Request, SchemaManager,
            __slice = [].slice;

            Request = require("./request");

            SchemaManager = require("./schema_manager");

            Action = require("./action");

            module.exports = Client = (function() {

              Client.discover = function() {
                var args, callback, options, request, url,
                _this = this;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                if (args.length === 2) {
                  url = args[0], callback = args[1];
                  options = {};
                } else if (args.length === 3) {
                  url = args[0], options = args[1], callback = args[2];
                }
                if (url.constructor !== String) {
                  throw new Error("Discovery URL must be a string");
                }
                request = {
                  url: url,
                  method: "GET",
                  headers: {
                    "Accept": "application/json"
                  }
                };
                if (options.gzip) {
                  request.headers["Accept-Encoding"] = "gzip";
                }
                return new Request(request, function(error, response) {
                  var client;
                  if (error) {
                    return callback(error);
                  } else {
                    if (response.data) {
                      client = new Client(response.data, options);
                      return callback(null, client);
                    } else {
                      return callback(new Error("Unparseable response body"));
                    }
                  }
                });
              };

              function Client(api, options) {
                var field, missing_fields, required_fields, _i, _len, _ref;
                this.api = api;
                this.options = options != null ? options : {};
                _ref = this.options, this.authorizer = _ref.authorizer, this.gzip = _ref.gzip;
                required_fields = ["schemas", "resources", "mappings"];
                missing_fields = [];
                for (_i = 0, _len = required_fields.length; _i < _len; _i++) {
                  field = required_fields[_i];
                  if (!this.api[field]) {
                    missing_fields.push(field);
                  }
                }
                if (missing_fields.length !== 0) {
                  throw new Error("API specification is missing fields: " + (missing_fields.join(', ')));
                }
                this.schema_manager = (function(func, args, ctor) {
                  ctor.prototype = func.prototype;
                  var child = new ctor,
                    result = func.apply(child, args),
                    t = typeof result;
                  return t == "object" || t == "function" ? result || child : child;
                })(SchemaManager, this.api.schemas, function() {});
                this.resource_constructors = this.create_resource_constructors(this.api.resources, this.api.mappings);
                this.resources = {};
                this.create_directory(this.api.mappings, this.resource_constructors);
              }

              Client.prototype.create_directory = function(mappings, constructors) {
                var mapping, name, _results,
                _this = this;
                _results = [];
                for (name in mappings) {
                  mapping = mappings[name];
                  _results.push((function(name, mapping) {
                    var constructor, query, url;
                    url = mapping.url, query = mapping.query;
                    if (!(url || query)) {
                      throw new Error("Mapping lacks a url, path, or template field");
                    }
                    if (constructor = constructors[name]) {
                      if (mapping.url) {
                        if (mapping.query) {
                          return _this.resources[name] = function(params) {
                            if (params == null) {
                              params = {};
                            }
                            return new constructor(params);
                          };
                        } else {
                          return _this.resources[name] = new constructor(null, {
                            url: mapping.url
                          });
                        }
                      }
                    } else {
                      throw new Error("No constructor for '" + name + "'");
                    }
                  })(name, mapping));
                }
                return _results;
              };

              Client.prototype.create = function(name, params) {
                var constructor;
                constructor = this.resource_constructors[name];
                return constructor(params, {});
              };

              Client.prototype.generate_url = function(mapping, params) {
                var key, keys, out, part, parts, path, query, query_string, schema, string, template, url, _i, _j, _len, _len1;
                url = this.api.service_url;
                if (template = mapping.template) {
                  parts = template.split("/");
                  out = [];
                  for (_i = 0, _len = parts.length; _i < _len; _i++) {
                    part = parts[_i];
                    if (part.indexOf(":") === 0) {
                      key = part.slice(1);
                      if (string = params[key]) {
                        out.push(string);
                      } else {
                        string = "Missing key: '" + key + "' in params: " + (JSON.stringify(params));
                        throw new Error(string);
                      }
                    } else {
                      out.push(part);
                    }
                  }
                  path = out.join("/");
                } else if (mapping.path) {
                  path = mapping.path;
                } else if (mapping.url) {
                  url = mapping.url;
                  path = "";
                } else {
                  throw new Error("Unusable URL generator: " + (JSON.stringify(mapping)));
                }
                query_string = "";
                if (query = mapping.query) {
                  parts = [];
                  keys = Object.keys(query).sort();
                  for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
                    key = keys[_j];
                    schema = query[key];
                    if (string = params[key]) {
                      parts.push("" + key + "=" + string);
                    }
                  }
                  if (parts.length > 0) {
                    query_string = "?" + (parts.join('&'));
                  } else {
                    query_string = "";
                  }
                }
                return encodeURI(url + path + query_string);
              };

              Client.prototype.create_resource_constructors = function(definitions, mappings) {
                var alias, constructor, constructors, definition, mapping, name, type, _i, _len, _ref;
                constructors = {};
                for (type in definitions) {
                  definition = definitions[type];
                  constructor = this.resource_constructor({
                    type: type,
                    definition: definition
                  });
                  constructors[type] = constructor;
                }
                for (name in mappings) {
                  mapping = mappings[name];
                  type = mapping.resource;
                  definition = definitions[type];
                  if (!definition) {
                    throw new Error("No resource defined for '" + type + "'");
                  }
                  constructor = this.resource_constructor({
                    type: type,
                    mapping: mapping,
                    definition: definition
                  });
                  constructors[name] = constructor;
                  if (definition.aliases) {
                    _ref = definition.aliases;
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      alias = _ref[_i];
                      constructors[alias] = constructor;
                    }
                  }
                }
                return constructors;
              };

              Client.prototype.resource_constructor = function(_arg) {
                var client, constructor, def, definition, mapping, method, name, type, _fn, _ref, _ref1;
                type = _arg.type, mapping = _arg.mapping, definition = _arg.definition;
                client = this;
                constructor = function(params, data) {
                  var key, path, query, template, url, value;
                  if (data == null) {
                    data = {};
                  }
                  if (mapping) {
                    url = mapping.url, path = mapping.path, template = mapping.template, query = mapping.query;
                    url || (url = data.url);
                    data.url = client.generate_url({
                      url: url,
                      path: path,
                      template: template,
                      query: query
                    }, params);
                  }
                  for (key in data) {
                    value = data[key];
                    this[key] = value;
                  }
                  return this;
                };
                constructor.prototype._actions = {};
                constructor.prototype.resource_type = type;
                if (mapping != null ? mapping.query : void 0) {
                  constructor.query = mapping.query;
                }
                Object.defineProperty(constructor.prototype, "patchboard_client", {
                  value: this,
                  enumerable: false
                });
                _ref = this.resource_methods;
                for (name in _ref) {
                  method = _ref[name];
                  constructor.prototype[name] = method;
                }
                _ref1 = definition.actions;
                _fn = function(name, def) {
                  var action;
                  action = constructor.prototype._actions[name] = new Action(client, name, def);
                  return constructor.prototype[name] = function() {
                    var args;
                    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    return action.request.apply(action, [this.url].concat(__slice.call(args)));
                  };
                };
                for (name in _ref1) {
                  def = _ref1[name];
                  _fn(name, def);
                }
                return constructor;
              };

              Client.prototype.resource_methods = {
                curl: function() {
                  var action, agent, args, body, command, header, headers, method, name, request, url, value;
                  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                  action = this._actions[name];
                  request = action.create_request.apply(action, [this.url].concat(__slice.call(args)));
                  method = request.method, url = request.url, headers = request.headers, body = request.body;
                  agent = headers["User-Agent"];
                  command = [];
                  command.push("curl -v -A '" + agent + "' -X " + method);
                  for (header in headers) {
                    value = headers[header];
                    if (header !== "User-Agent") {
                      command.push("  -H '" + header + ": " + value + "'");
                    }
                  }
                  if (body) {
                    command.push("  -d '" + (JSON.stringify(body)) + "'");
                  }
                  command.push("  " + url);
                  return command.join(" \\\n");
                }
              };

              Client.prototype.decorate = function(schema, data) {
                var constructor, d, name, _ref;
                if (name = (_ref = schema.id) != null ? _ref.split("#")[1] : void 0) {
                  if (constructor = this.resource_constructors[name]) {
                    d = data;
                    if (constructor.query) {
                      data = function(params) {
                        return new constructor(params, d);
                      };
                    } else {
                      data = new constructor(null, d);
                    }
                  }
                }
                return this._decorate(schema, data) || data;
              };

              Client.prototype._decorate = function(schema, data) {
                var addprop, i, item, key, ref, result, value, _i, _len, _ref, _ref1, _results;
                if (!schema || !data) {
                  return;
                }
                if (ref = schema.$ref) {
                  if (schema = this.schema_manager.find(ref)) {
                    return this.decorate(schema, data);
                  } else {
                    console.error("Can't find ref:", ref);
                    return data;
                  }
                } else {
                  if (schema.type === "array") {
                    if (schema.items) {
                      _results = [];
                      for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
                        item = data[i];
                        if (result = this.decorate(schema.items, item)) {
                          _results.push(data[i] = result);
                        } else {
                          _results.push(void 0);
                        }
                      }
                      return _results;
                    }
                  } else {
                    switch (schema.type) {
                    case "string":
                    case "number":
                    case "integer":
                    case "boolean":
                      return null;
                    default:
                      _ref = schema.properties;
                      for (key in _ref) {
                        value = _ref[key];
                        if (result = this.decorate(value, data[key])) {
                          data[key] = result;
                        }
                      }
                      if (addprop = schema.additionalProperties) {
                        for (key in data) {
                          value = data[key];
                          if (!((_ref1 = schema.properties) != null ? _ref1[key] : void 0)) {
                            data[key] = this.decorate(addprop, value);
                          }
                        }
                      }
                      return data;
                    }
                  }
                }
              };

              return Client;

            })();

          },

          "15c17f74b3a4728e12bc597d2db090fa": // from: node_modules/patchboard-js/src/request.coffee
          function(exports, require, module, __filename, __dirname) {
            var Request, Response, ResponseContent, URL, corsetCase, http, https, zlib;

            http = require("http");

            https = require("https");

            URL = require("url");

            try {
              zlib = require("zlib");
            } catch (error) {
              zlib = null;
            }

            corsetCase = function(string) {
              return string.toLowerCase().replace("_", "-").replace(/(^|-)(\w)/g, function(s) {
                return s.toUpperCase();
              });
            };

            module.exports = Request = (function() {

              function Request(options, callback) {
                var client, hostname, parameters, path, port, protocol, raw, timeout, _ref, _ref1,
                _this = this;
                this.url = options.url, this.method = options.method, this.headers = options.headers, this.body = options.body, timeout = options.timeout, this.redirects = options.redirects;
                this.method = this.method.toUpperCase();
                if ((_ref = this.redirects) == null) {
                  this.redirects = 1;
                }
                _ref1 = URL.parse(this.url), protocol = _ref1.protocol, hostname = _ref1.hostname, port = _ref1.port, path = _ref1.path;
                client = (protocol === "http:" ? http : https);
                parameters = {
                  hostname: hostname,
                  port: port,
                  path: path,
                  method: this.method,
                  headers: this.headers
                };
                if (this.body && (typeof Buffer !== "undefined" && Buffer !== null)) {
                  this.headers["Content-Length"] = Buffer.byteLength(this.body);
                }
                raw = client.request(parameters, function(response) {
                  switch (response.statusCode) {
                  case 300:
                  case 301:
                  case 302:
                  case 303:
                  case 307:
                    return _this.redirect(_this, response, callback);
                  case 304:
                  case 305:
                    return callback(new Error("" + response.statusCode + " handling not yet implemented"));
                  default:
                    return response = new Response(response, callback);
                  }
                });
                raw.on("error", function(error) {
                  return callback(error);
                });
                if (timeout) {
                  raw.setTimeout(timeout, function() {
                    return raw.abort();
                  });
                }
                if (this.body) {
                  raw.write(this.body.toString());
                }
                raw.end();
              }

              Request.prototype.redirect = function(request, response, callback) {
                var body, headers, location, method, redirects, timeout;
                method = request.method, headers = request.headers, body = request.body, timeout = request.timeout, redirects = request.redirects;
                if (!(method === "GET" || method === "HEAD")) {
                  return callback(new Error("Received redirect for method other than GET or HEAD"));
                } else if (redirects === 0) {
                  return callback(new Error("Exceeded allowed number of redirects"));
                } else {
                  location = response.headers["Location"] || response.headers["location"];
                  if (location) {
                    return new Request({
                      url: location,
                      redirects: redirects - 1,
                      method: method,
                      headers: headers,
                      body: body,
                      timeout: timeout
                    }, callback);
                  } else {
                    return callback(new Error("Redirect response did not provide Location"));
                  }
                }
              };

              return Request;

            })();

            Response = (function() {

              function Response(raw, callback) {
                var key, value, _ref,
                _this = this;
                this.raw = raw;
                this._content = new ResponseContent(this);
                this.status = this.raw.statusCode;
                this.headers = {};
                this._normalized = {};
                _ref = this.raw.headers;
                for (key in _ref) {
                  value = _ref[key];
                  this.headers[key] = value;
                  this._normalized[corsetCase(key)] = value;
                }
                this.raw.on("end", function() {
                  return _this._content.process(function(content) {
                    _this.content = content;
                    _this.body = _this.content.body;
                    _this.data = _this.content.data;
                    return callback(null, _this);
                  });
                });
              }

              Response.prototype.getHeader = function(name) {
                return this.headers[name] || this._normalized[corsetCase(name)];
              };

              return Response;

            })();

            ResponseContent = (function() {

              function ResponseContent(response) {
                var encoding, headers,
                _this = this;
                this.response = response;
                this.raw = this.response.raw;
                this.chunks = [];
                this.length = 0;
                headers = this.raw.headers;
                this.type = headers["Content-Type"] || headers["content-type"];
                switch ((encoding = headers["Content-Encoding"] || headers["content-encoding"])) {
                case "gzip":
                  this.encoding = encoding;
                  break;
                default:
                  this.encoding = null;
                }
                this.raw.on("data", function(chunk) {
                  _this.chunks.push(chunk);
                  return _this.length += chunk.length;
                });
              }

              ResponseContent.prototype.process = function(callback) {
                var _this = this;
                if (typeof Buffer !== "undefined" && Buffer !== null) {
                  this.buffer = Buffer.concat(this.chunks, this.length);
                } else {
                  this.buffer = this.chunks.join("");
                }
                return this.process_encoding(function() {
                  return _this.process_type(callback);
                });
              };

              ResponseContent.prototype.process_encoding = function(callback) {
                var _this = this;
                if (this.encoding && zlib) {
                  return zlib.gunzip(this.buffer, function(error, buffer) {
                    _this.body = buffer.toString("utf-8");
                    return callback();
                  });
                } else {
                  this.body = this.buffer.toString("utf-8");
                  return callback();
                }
              };

              ResponseContent.prototype.process_type = function(callback) {
                if (this.type) {
                  if (/json/.test(this.type)) {
                    try {
                      this.data = JSON.parse(this.body);
                    } catch (error) {
                      this.data = void 0;
                    }
                  }
                }
                return callback({
                  buffer: this.buffer,
                  body: this.body,
                  data: this.data
                });
              };

              return ResponseContent;

            })();

          },

          "b11267eae7cb3a8dd3670a00ed307031": // from: node_modules/patchboard-js/src/schema_manager.coffee
          function(exports, require, module, __filename, __dirname) {
            var JSCK, SchemaManager,
            __slice = [].slice;

            JSCK = require("jsck");

            module.exports = SchemaManager = (function() {

              function SchemaManager() {
                var definition, definitions, name, schema, schemas, _i, _len, _ref;
                schemas = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                this.schemas = schemas;
                _ref = this.schemas;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  schema = _ref[_i];
                  if (definitions = schema.definitions) {
                    for (name in definitions) {
                      definition = definitions[name];
                      definition.id || (definition.id = "#" + name);
                    }
                  }
                }
                this.jsck = (function(func, args, ctor) {
                  ctor.prototype = func.prototype;
                  var child = new ctor,
                    result = func.apply(child, args),
                    t = typeof result;
                  return t == "object" || t == "function" ? result || child : child;
                })(JSCK.draft3, this.schemas, function() {});
                this.uris = this.jsck.references;
              }

              SchemaManager.prototype.find = function() {
                var args, _ref;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return (_ref = this.jsck).find.apply(_ref, args);
              };

              return SchemaManager;

            })();

          },

          "c4f9141dbd0d7a4e3dd3d1dc0a64c667": // from: 
          function(exports, require, module, __filename, __dirname) {
            // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
            //
            // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
            //
            // Originally from narwhal.js (http://narwhaljs.org)
            // Copyright (c) 2009 Thomas Robinson <280north.com>
            //
            // Permission is hereby granted, free of charge, to any person obtaining a copy
            // of this software and associated documentation files (the 'Software'), to
            // deal in the Software without restriction, including without limitation the
            // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
            // sell copies of the Software, and to permit persons to whom the Software is
            // furnished to do so, subject to the following conditions:
            //
            // The above copyright notice and this permission notice shall be included in
            // all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
            // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
            // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

            // UTILITY
            var util = require('util');
            var pSlice = Array.prototype.slice;

            // 1. The assert module provides functions that throw
            // AssertionError's when particular conditions are not met. The
            // assert module must conform to the following interface.

            var assert = module.exports = ok;

            // 2. The AssertionError is defined in assert.
            // new assert.AssertionError({ message: message,
            //                             actual: actual,
            //                             expected: expected })

            assert.AssertionError = function AssertionError(options) {
              this.name = 'AssertionError';
              this.message = options.message;
              this.actual = options.actual;
              this.expected = options.expected;
              this.operator = options.operator;
              var stackStartFunction = options.stackStartFunction || fail;

              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
              }
            };

            // assert.AssertionError instanceof Error
            util.inherits(assert.AssertionError, Error);

            function replacer(key, value) {
              if (value === undefined) {
                return '' + value;
              }
              if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
                return value.toString();
              }
              if (typeof value === 'function' || value instanceof RegExp) {
                return value.toString();
              }
              return value;
            }

            function truncate(s, n) {
              if (typeof s == 'string') {
                return s.length < n ? s : s.slice(0, n);
              } else {
                return s;
              }
            }

            assert.AssertionError.prototype.toString = function() {
              if (this.message) {
                return [this.name + ':', this.message].join(' ');
              } else {
                return [
                this.name + ':',
                truncate(JSON.stringify(this.actual, replacer), 128),
                this.operator,
                truncate(JSON.stringify(this.expected, replacer), 128)].join(' ');
              }
            };

            // At present only the three keys mentioned above are used and
            // understood by the spec. Implementations or sub modules can pass
            // other keys to the AssertionError's constructor - they will be
            // ignored.

            // 3. All of the following functions must throw an AssertionError
            // when a corresponding condition is not met, with a message that
            // may be undefined if not provided.  All assertion methods provide
            // both the actual and expected values to the assertion error for
            // display purposes.

            function fail(actual, expected, message, operator, stackStartFunction) {
              throw new assert.AssertionError({
                message: message,
                actual: actual,
                expected: expected,
                operator: operator,
                stackStartFunction: stackStartFunction
              });
            }

            // EXTENSION! allows for well behaved errors defined elsewhere.
            assert.fail = fail;

            // 4. Pure assertion tests whether a value is truthy, as determined
            // by !!guard.
            // assert.ok(guard, message_opt);
            // This statement is equivalent to assert.equal(true, !!guard,
            // message_opt);. To test strictly for the value true, use
            // assert.strictEqual(true, guard, message_opt);.

            function ok(value, message) {
              if ( !! !value) fail(value, true, message, '==', assert.ok);
            }
            assert.ok = ok;

            // 5. The equality assertion tests shallow, coercive equality with
            // ==.
            // assert.equal(actual, expected, message_opt);

            assert.equal = function equal(actual, expected, message) {
              if (actual != expected) fail(actual, expected, message, '==', assert.equal);
            };

            // 6. The non-equality assertion tests for whether two objects are not equal
            // with != assert.notEqual(actual, expected, message_opt);

            assert.notEqual = function notEqual(actual, expected, message) {
              if (actual == expected) {
                fail(actual, expected, message, '!=', assert.notEqual);
              }
            };

            // 7. The equivalence assertion tests a deep equality relation.
            // assert.deepEqual(actual, expected, message_opt);

            assert.deepEqual = function deepEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected)) {
                fail(actual, expected, message, 'deepEqual', assert.deepEqual);
              }
            };

            function _deepEqual(actual, expected) {
              // 7.1. All identical values are equivalent, as determined by ===.
              if (actual === expected) {
                return true;

              } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
                if (actual.length != expected.length) return false;

                for (var i = 0; i < actual.length; i++) {
                  if (actual[i] !== expected[i]) return false;
                }

                return true;

                // 7.2. If the expected value is a Date object, the actual value is
                // equivalent if it is also a Date object that refers to the same time.
              } else if (actual instanceof Date && expected instanceof Date) {
                return actual.getTime() === expected.getTime();

                // 7.3 If the expected value is a RegExp object, the actual value is
                // equivalent if it is also a RegExp object with the same source and
                // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
              } else if (actual instanceof RegExp && expected instanceof RegExp) {
                return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

                // 7.4. Other pairs that do not both pass typeof value == 'object',
                // equivalence is determined by ==.
              } else if (typeof actual != 'object' && typeof expected != 'object') {
                return actual == expected;

                // 7.5 For all other Object pairs, including Array objects, equivalence is
                // determined by having the same number of owned properties (as verified
                // with Object.prototype.hasOwnProperty.call), the same set of keys
                // (although not necessarily the same order), equivalent values for every
                // corresponding key, and an identical 'prototype' property. Note: this
                // accounts for both named and indexed properties on Arrays.
              } else {
                return objEquiv(actual, expected);
              }
            }

            function isUndefinedOrNull(value) {
              return value === null || value === undefined;
            }

            function isArguments(object) {
              return Object.prototype.toString.call(object) == '[object Arguments]';
            }

            function objEquiv(a, b) {
              if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
              // an identical 'prototype' property.
              if (a.prototype !== b.prototype) return false;
              //~~~I've managed to break Object.keys through screwy arguments passing.
              //   Converting to array solves the problem.
              if (isArguments(a)) {
                if (!isArguments(b)) {
                  return false;
                }
                a = pSlice.call(a);
                b = pSlice.call(b);
                return _deepEqual(a, b);
              }
              try {
                var ka = Object.keys(a),
                  kb = Object.keys(b),
                  key, i;
              } catch (e) { //happens when one is a string literal and the other isn't
                return false;
              }
              // having the same number of owned properties (keys incorporates
              // hasOwnProperty)
              if (ka.length != kb.length) return false;
              //the same set of keys (although not necessarily the same order),
              ka.sort();
              kb.sort();
              //~~~cheap key test
              for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] != kb[i]) return false;
              }
              //equivalent values for every corresponding key, and
              //~~~possibly expensive deep test
              for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!_deepEqual(a[key], b[key])) return false;
              }
              return true;
            }

            // 8. The non-equivalence assertion tests for any deep inequality.
            // assert.notDeepEqual(actual, expected, message_opt);

            assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
              if (_deepEqual(actual, expected)) {
                fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
              }
            };

            // 9. The strict equality assertion tests strict equality, as determined by ===.
            // assert.strictEqual(actual, expected, message_opt);

            assert.strictEqual = function strictEqual(actual, expected, message) {
              if (actual !== expected) {
                fail(actual, expected, message, '===', assert.strictEqual);
              }
            };

            // 10. The strict non-equality assertion tests for strict inequality, as
            // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

            assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
              if (actual === expected) {
                fail(actual, expected, message, '!==', assert.notStrictEqual);
              }
            };

            function expectedException(actual, expected) {
              if (!actual || !expected) {
                return false;
              }

              if (expected instanceof RegExp) {
                return expected.test(actual);
              } else if (actual instanceof expected) {
                return true;
              } else if (expected.call({}, actual) === true) {
                return true;
              }

              return false;
            }

            function _throws(shouldThrow, block, expected, message) {
              var actual;

              if (typeof expected === 'string') {
                message = expected;
                expected = null;
              }

              try {
                block();
              } catch (e) {
                actual = e;
              }

              message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

              if (shouldThrow && !actual) {
                fail(actual, expected, 'Missing expected exception' + message);
              }

              if (!shouldThrow && expectedException(actual, expected)) {
                fail(actual, expected, 'Got unwanted exception' + message);
              }

              if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
                throw actual;
              }
            }

            // 11. Expected to throw an error:
            // assert.throws(block, Error_opt, message_opt);

            assert.throws = function(block, /*optional*/ error, /*optional*/ message) {
              _throws.apply(this, [true].concat(pSlice.call(arguments)));
            };

            // EXTENSION! This is annoying to write outside this module.
            assert.doesNotThrow = function(block, /*optional*/ message) {
              _throws.apply(this, [false].concat(pSlice.call(arguments)));
            };

            assert.ifError = function(err) {
              if (err) {
                throw err;
              }
            };

          },

          "5d6e2c2d895132330e91af96bc1409c7": // from: 
          function(exports, require, module, __filename, __dirname) {
            //
            // Adapted from http-browserify
            //


            var http = module.exports;
            var EventEmitter = require('events').EventEmitter;
            var Request;

            http.request = function(params, cb) {
              if (!params) params = {};
              if (!params.host) params.host = window.location.host.split(':')[0];
              if (!params.port) params.port = window.location.port;

              var req = new Request(new xhrHttp, params);
              if (cb) req.on('response', cb);
              return req;
            };

            http.get = function(params, cb) {
              params.method = 'GET';
              var req = http.request(params, cb);
              req.end();
              return req;
            };

            http.Agent = function() {};
            http.Agent.defaultMaxSockets = 4;

            var xhrHttp = (function() {
              if (typeof window === 'undefined') {
                throw new Error('no window object present');
              } else if (window.XMLHttpRequest) {
                return window.XMLHttpRequest;
              } else if (window.ActiveXObject) {
                var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
                for (var i = 0; i < axs.length; i++) {
                  try {
                    var ax = new(window.ActiveXObject)(axs[i]);
                    return function() {
                      if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                      } else {
                        return new(window.ActiveXObject)(axs[i]);
                      }
                    };
                  } catch (e) {}
                }
                throw new Error('ajax not supported in this browser')
              } else {
                throw new Error('ajax not supported in this browser');
              }
            })();


            Request = (function() {
              var EventEmitter = require('events').EventEmitter;
              var Response;
              var concatStream;

              var Request = function(xhr, params) {
                var self = this;
                self.xhr = xhr;
                self.body = concatStream()

                var uri = params.host + ':' + params.port + (params.path || '/');

                xhr.open(
                params.method || 'GET', (params.scheme || 'http') + '://' + uri,
                true);

                if (params.headers) {
                  Object.keys(params.headers).forEach(function(key) {
                    if (!self.isSafeRequestHeader(key)) return;
                    var value = params.headers[key];
                    if (Array.isArray(value)) {
                      value.forEach(function(v) {
                        xhr.setRequestHeader(key, v);
                      });
                    } else xhr.setRequestHeader(key, value)
                  });
                }

                var res = new Response(xhr);
                res.on('ready', function() {
                  self.emit('response', res);
                });

                xhr.onreadystatechange = function() {
                  res.handle(xhr);
                };
              };

              Request.prototype = new EventEmitter;

              Request.prototype.setHeader = function(key, value) {
                if ((Array.isArray && Array.isArray(value)) || value instanceof Array) {
                  for (var i = 0; i < value.length; i++) {
                    this.xhr.setRequestHeader(key, value[i]);
                  }
                } else {
                  this.xhr.setRequestHeader(key, value);
                }
              };

              Request.prototype.write = function(s) {
                this.body.write(s);
              };

              Request.prototype.end = function(s) {
                if (s !== undefined) this.body.write(s);
                this.body.end()
                this.xhr.send(this.body.getBody());
              };

              // Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
              Request.unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];

              Request.prototype.isSafeRequestHeader = function(headerName) {
                if (!headerName) return false;
                return (Request.unsafeHeaders.indexOf(headerName.toLowerCase()) === -1)
              };

              Response = (function() {

                var EventEmitter = require('events').EventEmitter;

                var Response = function(xhr) {
                  this.xhr = xhr;
                  this.offset = 0;
                };

                Response.prototype = new EventEmitter;

                var capable = {
                  streaming: true,
                  status2: true
                };

                function parseHeaders(xhr) {
                  var lines = xhr.getAllResponseHeaders().split(/\r?\n/);
                  var headers = {};
                  for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    if (line === '') continue;

                    var m = line.match(/^([^:]+):\s*(.*)/);
                    if (m) {
                      var key = m[1].toLowerCase(),
                        value = m[2];

                      if (headers[key] !== undefined) {
                        if ((Array.isArray && Array.isArray(headers[key])) || headers[key] instanceof Array) {
                          headers[key].push(value);
                        } else {
                          headers[key] = [headers[key], value];
                        }
                      } else {
                        headers[key] = value;
                      }
                    } else {
                      headers[line] = true;
                    }
                  }
                  return headers;
                }

                Response.prototype.getResponse = function(xhr) {
                  var respType = xhr.responseType.toLowerCase();
                  if (respType === "blob") return xhr.responseBlob;
                  if (respType === "arraybuffer") return xhr.response;
                  return xhr.responseText;
                }

                Response.prototype.getHeader = function(key) {
                  return this.headers[key.toLowerCase()] || this.xhr.getResponseHeader(key);
                };

                Response.prototype.handle = function(xhr) {
                  if (xhr.readyState === 2 && capable.status2) {
                    try {
                      this.statusCode = xhr.status;
                      this.headers = parseHeaders(xhr);
                    } catch (err) {
                      capable.status2 = false;
                    }

                    if (capable.status2) {
                      this.emit('ready');
                    }
                  } else if (capable.streaming && xhr.readyState === 3) {
                    try {
                      if (!this.statusCode) {
                        this.statusCode = xhr.status;
                        this.headers = parseHeaders(xhr);
                        this.emit('ready');
                      }
                    } catch (err) {}

                    try {
                      this.write(xhr);
                    } catch (err) {
                      capable.streaming = false;
                    }
                  } else if (xhr.readyState === 4) {
                    if (!this.statusCode) {
                      this.statusCode = xhr.status;
                      this.emit('ready');
                    }
                    this.write(xhr);

                    if (xhr.error) {
                      this.emit('error', this.getResponse(xhr));
                    } else this.emit('end');
                  }
                };

                Response.prototype.write = function(xhr) {
                  var respBody = this.getResponse(xhr);
                  if (respBody.toString().match(/ArrayBuffer/)) {
                    this.emit('data', new Uint8Array(respBody, this.offset));
                    this.offset = respBody.byteLength;
                    return;
                  }
                  if (respBody.length > this.offset) {
                    this.emit('data', respBody.slice(this.offset));
                    this.offset = respBody.length;
                  }
                };

                return Response;

              })();

              concatStream = (function() {

                var stream = require('stream')
                var util = require('util')

                  function ConcatStream(cb) {
                    stream.Stream.call(this)
                    this.writable = true
                    if (cb) this.cb = cb
                    this.body = []
                    this.on('error', function(err) {
                      if (this.cb) this.cb(err)
                    })
                  }

                util.inherits(ConcatStream, stream.Stream)

                ConcatStream.prototype.write = function(chunk) {
                  this.body.push(chunk)
                }

                ConcatStream.prototype.destroy = function() {}

                ConcatStream.prototype.arrayConcat = function(arrs) {
                  if (arrs.length === 0) return []
                  if (arrs.length === 1) return arrs[0]
                  return arrs.reduce(function(a, b) {
                    return a.concat(b)
                  })
                }

                ConcatStream.prototype.isArray = function(arr) {
                  var isArray = Array.isArray(arr)
                  var isTypedArray = arr.toString().match(/Array/)
                  return isArray || isTypedArray
                }

                ConcatStream.prototype.getBody = function() {
                  if (this.body.length === 0) return
                  if (typeof(this.body[0]) === "string") return this.body.join('')
                  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)
                  if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {
                    return Buffer.concat(this.body)
                  }
                  return this.body
                }

                ConcatStream.prototype.end = function() {
                  if (this.cb) this.cb(false, this.getBody())
                }

                var exports = function(cb) {
                  return new ConcatStream(cb)
                }

                exports.ConcatStream = ConcatStream

                return exports;

              })();

              return Request;

            })();



          },

          "8f99cc2b75044ae1f45cefc6948e42b3": // from: 
          function(exports, require, module, __filename, __dirname) {
            module.exports = require('http');

          },

          "e78828afe729e92d62b73d30c483888f": // from: 
          function(exports, require, module, __filename, __dirname) {
            var Stat, base64Decode, fs, getFile;

            getFile = function(path) {
              var file, part, parts, _i, _len;
              parts = path.split("/").slice(1);
              file = global.filesystem.root;
              for (_i = 0, _len = parts.length; _i < _len; _i++) {
                part = parts[_i];
                if (!(file = file[part])) {
                  throw "File not found at '" + path + "'";
                }
              }
              return file;
            };

            Stat = (function() {

              function Stat(path) {
                this.file = getFile(path);
              }

              Stat.prototype.isDirectory = function() {
                return this.file.__stat.type === "directory";
              };

              Stat.prototype.isFile = function() {
                return this.file.__stat.type === "file";
              };

              Stat.prototype.isSymbolicLink = function() {
                return false;
              };

              return Stat;

            })();

            base64Decode = function(string) {
              return decodeURIComponent(escape(window.atob(string)));
            };

            var fs = {
              readFileSync: function(path, encoding) {
                var file;
                file = getFile(path);
                return global.filesystem.read(file);
              },
              readdirSync: function(path) {
                var file;
                file = getFile(path);
                if (file.__stat.type === "directory") {
                  var result = [];
                  for (var key in file) {
                    // TODO: this is not a great convention, since it's hardly
                    // impossible that a file might start with two underscores
                    if (!(/^__/.test(key))) {
                      result.push(key);
                    }
                  }
                  return result;
                } else {
                  throw "Not a directory: '" + path + "'";
                }
              },
              statSync: function(path) {
                return new Stat(path);
              },
              lstatSync: function(path) {
                return this.statSync(path);
              },
              // realpath Sync adapted from Node source
              realpathSync: function realpathSync(p, cache) {

                var isWindows = process.platform === 'win32';

                // Regexp that finds the next partion of a (partial) path
                // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
                if (isWindows) {
                  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
                } else {
                  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
                }

                // Regex to find the device root, including trailing slash. E.g. 'c:\\'.
                if (isWindows) {
                  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
                } else {
                  var splitRootRe = /^[\/]*/;
                }

                var pathModule = NativeModule.require("path");
                var normalize = pathModule.normalize;

                // make p is absolute
                p = pathModule.resolve(p);

                if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
                  return cache[p];
                }

                var original = p,
                  seenLinks = {},
                  knownHard = {};

                // current character position in p
                var pos;
                // the partial path so far, including a trailing slash if any
                var current;
                // the partial path without a trailing slash (except when pointing at a root)
                var base;
                // the partial path scanned in the previous round, with slash
                var previous;

                start();

                function start() {
                  // Skip over roots
                  var m = splitRootRe.exec(p);
                  pos = m[0].length;
                  current = m[0];
                  base = m[0];
                  previous = '';

                  // On windows, check that the root exists. On unix there is no need.
                  if (isWindows && !knownHard[base]) {
                    fs.lstatSync(base);
                    knownHard[base] = true;
                  }
                }

                // walk down the path, swapping out linked pathparts for their real
                // values
                // NB: p.length changes.
                while (pos < p.length) {
                  // find the next part
                  nextPartRe.lastIndex = pos;
                  var result = nextPartRe.exec(p);
                  previous = current;
                  current += result[0];
                  base = previous + result[1];
                  pos = nextPartRe.lastIndex;

                  // continue if not a symlink
                  if (knownHard[base] || (cache && cache[base] === base)) {
                    continue;
                  }

                  var resolvedLink;
                  if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
                    // some known symbolic link.  no need to stat again.
                    resolvedLink = cache[base];
                  } else {
                    var stat = fs.lstatSync(base);
                    if (!stat.isSymbolicLink()) {
                      knownHard[base] = true;
                      if (cache) cache[base] = base;
                      continue;
                    }

                    // read the link if it wasn't read before
                    // dev/ino always return 0 on windows, so skip the check.
                    var linkTarget = null;
                    if (!isWindows) {
                      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
                      if (seenLinks.hasOwnProperty(id)) {
                        linkTarget = seenLinks[id];
                      }
                    }
                    if (linkTarget === null) {
                      fs.statSync(base);
                      linkTarget = fs.readlinkSync(base);
                    }
                    resolvedLink = pathModule.resolve(previous, linkTarget);
                    // track this, if given a cache.
                    if (cache) cache[base] = resolvedLink;
                    if (!isWindows) seenLinks[id] = linkTarget;
                  }

                  // resolve the link, then start over
                  p = pathModule.resolve(resolvedLink, p.slice(pos));
                  start();
                }

                if (cache) cache[original] = p;

                return p;
              }
            };

            module.exports = fs;
          },

          "223f09f17e4aff9f2d05493c688f7934": // from: 
          function(exports, require, module, __filename, __dirname) {
            //
            // Adapted from Node source
            //

            var NativeModule = require('native_module');
            var Script = process.binding('evals').NodeScript;
            var runInThisContext = Script.runInThisContext;
            var runInNewContext = Script.runInNewContext;
            var assert = require('assert').ok;


            // If obj.hasOwnProperty has been overridden, then calling
            // obj.hasOwnProperty(prop) will break.
            // See: https://github.com/joyent/node/issues/1707
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }


            function Module(id, parent) {
              this.id = id;
              this.exports = {};
              this.parent = parent;
              if (parent && parent.children) {
                parent.children.push(this);
              }

              this.filename = null;
              this.loaded = false;
              this.children = [];
            }
            module.exports = Module;

            // Set the environ variable NODE_MODULE_CONTEXTS=1 to make node load all
            // modules in thier own context.
            Module._contextLoad = (+process.env['NODE_MODULE_CONTEXTS'] > 0);
            Module._cache = {};
            Module._pathCache = {};
            Module._extensions = {};
            var modulePaths = [];
            Module.globalPaths = [];

            Module.wrapper = NativeModule.wrapper;
            Module.wrap = NativeModule.wrap;

            var path = NativeModule.require('path');

            Module._debug = function() {};
            if (process.env.NODE_DEBUG && /module/.test(process.env.NODE_DEBUG)) {
              Module._debug = function(x) {
                console.error(x);
              };
            }


            // We use this alias for the preprocessor that filters it out
            var debug = Module._debug;


            // given a module name, and a list of paths to test, returns the first
            // matching file in the following precedence.
            //
            // require("a.<ext>")
            //   -> a.<ext>
            //
            // require("a")
            //   -> a
            //   -> a.<ext>
            //   -> a/index.<ext>

            function statPath(path) {
              var fs = NativeModule.require('fs');
              try {
                return fs.statSync(path);
              } catch (ex) {}
              return false;
            }

            // check if the directory is a package.json dir
            var packageCache = {};

            function readPackage(requestPath) {
              if (hasOwnProperty(packageCache, requestPath)) {
                return packageCache[requestPath];
              }

              var fs = NativeModule.require('fs');
              try {
                var jsonPath = path.resolve(requestPath, 'package.json');
                var json = fs.readFileSync(jsonPath, 'utf8');
              } catch (e) {
                return false;
              }

              try {
                var pkg = packageCache[requestPath] = JSON.parse(json);
              } catch (e) {
                e.path = jsonPath;
                e.message = 'Error parsing ' + jsonPath + ': ' + e.message;
                throw e;
              }
              return pkg;
            }

            function tryPackage(requestPath, exts) {
              var pkg = readPackage(requestPath);

              if (!pkg || !pkg.main) return false;

              var filename = path.resolve(requestPath, pkg.main);
              return tryFile(filename) || tryExtensions(filename, exts) || tryExtensions(path.resolve(filename, 'index'), exts);
            }

            // In order to minimize unnecessary lstat() calls,
            // this cache is a list of known-real paths.
            // Set to an empty object to reset.
            Module._realpathCache = {};

            // check if the file exists and is not a directory
            function tryFile(requestPath) {
              var fs = NativeModule.require('fs');
              var stats = statPath(requestPath);
              if (stats && !stats.isDirectory()) {
                return fs.realpathSync(requestPath, Module._realpathCache);
              }
              return false;
            }

            // given a path check a the file exists with any of the set extensions
            function tryExtensions(p, exts) {
              for (var i = 0, EL = exts.length; i < EL; i++) {
                var filename = tryFile(p + exts[i]);

                if (filename) {
                  return filename;
                }
              }
              return false;
            }


            Module._findPath = function(request, paths) {
              var exts = Object.keys(Module._extensions);

              if (request.charAt(0) === '/') {
                paths = [''];
              }

              var trailingSlash = (request.slice(-1) === '/');

              var cacheKey = JSON.stringify({
                request: request,
                paths: paths
              });
              if (Module._pathCache[cacheKey]) {
                return Module._pathCache[cacheKey];
              }

              // For each path
              for (var i = 0, PL = paths.length; i < PL; i++) {
                var basePath = path.resolve(paths[i], request);
                var filename;

                if (!trailingSlash) {
                  // try to join the request to the path
                  filename = tryFile(basePath);

                  if (!filename && !trailingSlash) {
                    // try it with each of the extensions
                    filename = tryExtensions(basePath, exts);
                  }
                }

                if (!filename) {
                  filename = tryPackage(basePath, exts);
                }

                if (!filename) {
                  // try it with each of the extensions at "index"
                  filename = tryExtensions(path.resolve(basePath, 'index'), exts);
                }

                if (filename) {
                  Module._pathCache[cacheKey] = filename;
                  return filename;
                }
              }
              return false;
            };

            // 'from' is the __dirname of the module.
            Module._nodeModulePaths = function(from) {
              // guarantee that 'from' is absolute.
              from = path.resolve(from);

              // note: this approach *only* works when the path is guaranteed
              // to be absolute.  Doing a fully-edge-case-correct path.split
              // that works on both Windows and Posix is non-trivial.
              var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\//;
              // yes, '/' works on both, but let's be a little canonical.
              var joiner = process.platform === 'win32' ? '\\' : '/';
              var paths = [];
              var parts = from.split(splitRe);

              for (var tip = parts.length - 1; tip >= 0; tip--) {
                // don't search in .../node_modules/node_modules
                if (parts[tip] === 'node_modules') continue;
                var dir = parts.slice(0, tip + 1).concat('node_modules').join(joiner);
                paths.push(dir);
              }

              return paths;
            };


            Module._resolveLookupPaths = function(request, parent) {
              if (NativeModule.exists(request)) {
                return [request, []];
              }

              var start = request.substring(0, 2);
              if (start !== './' && start !== '..') {
                var paths = modulePaths;
                if (parent) {
                  if (!parent.paths) parent.paths = [];
                  paths = parent.paths.concat(paths);
                }
                return [request, paths];
              }

              // with --eval, parent.id is not set and parent.filename is null
              if (!parent || !parent.id || !parent.filename) {
                // make require('./path/to/foo') work - normally the path is taken
                // from realpath(__filename) but with eval there is no filename
                var mainPaths = ['.'].concat(modulePaths);
                mainPaths = Module._nodeModulePaths('.').concat(mainPaths);
                return [request, mainPaths];
              }

              // Is the parent an index module?
              // We can assume the parent has a valid extension,
              // as it already has been accepted as a module.
              var isIndex = /^index\.\w+?$/.test(path.basename(parent.filename));
              var parentIdPath = isIndex ? parent.id : path.dirname(parent.id);
              var id = path.resolve(parentIdPath, request);

              // make sure require('./path') and require('path') get distinct ids, even
              // when called from the toplevel js file
              if (parentIdPath === '.' && id.indexOf('/') === -1) {
                id = './' + id;
              }

              debug('RELATIVE: requested:' + request + ' set ID to: ' + id + ' from ' + parent.id);

              return [id, [path.dirname(parent.filename)]];
            };


            Module._load = function(request, parent, isMain) {
              if (parent) {
                debug('Module._load REQUEST  ' + (request) + ' parent: ' + parent.id);
              }

              var filename = Module._resolveFilename(request, parent);

              var cachedModule = Module._cache[filename];
              if (cachedModule) {
                return cachedModule.exports;
              }

              if (NativeModule.exists(filename)) {
                // REPL is a special case, because it needs the real require.
                if (filename == 'repl') {
                  var replModule = new Module('repl');
                  replModule._compile(NativeModule.getSource('repl'), 'repl.js');
                  NativeModule._cache.repl = replModule;
                  return replModule.exports;
                }

                debug('load native module ' + request);
                return NativeModule.require(filename);
              }

              var module = new Module(filename, parent);

              if (isMain) {
                process.mainModule = module;
                module.id = '.';
              }

              Module._cache[filename] = module;

              var hadException = true;

              try {
                module.load(filename);
                hadException = false;
              } finally {
                if (hadException) {
                  delete Module._cache[filename];
                }
              }

              return module.exports;
            };

            Module._resolveFilename = function(request, parent) {
              if (NativeModule.exists(request)) {
                return request;
              }

              var resolvedModule = Module._resolveLookupPaths(request, parent);
              var id = resolvedModule[0];
              var paths = resolvedModule[1];

              // look up the filename first, since that's the cache key.
              debug('looking for ' + JSON.stringify(id) + ' in ' + JSON.stringify(paths));

              var filename = Module._findPath(request, paths);
              if (!filename) {
                var err = new Error("Cannot find module '" + request + "'");
                err.code = 'MODULE_NOT_FOUND';
                throw err;
              }
              return filename;
            };


            Module.prototype.load = function(filename) {
              debug('load ' + JSON.stringify(filename) + ' for module ' + JSON.stringify(this.id));

              assert(!this.loaded);
              this.filename = filename;
              this.paths = Module._nodeModulePaths(path.dirname(filename));

              var extension = path.extname(filename) || '.js';
              if (!Module._extensions[extension]) extension = '.js';
              Module._extensions[extension](this, filename);
              this.loaded = true;
            };


            Module.prototype.require = function(path) {
              return Module._load(path, this);
            };


            // Resolved path to process.argv[1] will be lazily placed here
            // (needed for setting breakpoint when called with --debug-brk)
            var resolvedArgv;


            // Returns exception if any
            Module.prototype._compile = function(content, filename) {
              var self = this;
              // remove shebang
              content = content.replace(/^\#\!.*/, '');

              function require(path) {
                return self.require(path);
              }

              require.resolve = function(request) {
                return Module._resolveFilename(request, self);
              };

              Object.defineProperty(require, 'paths', {
                get: function() {
                  throw new Error('require.paths is removed. Use ' + 'node_modules folders, or the NODE_PATH ' + 'environment variable instead.');
                }
              });

              require.main = process.mainModule;

              // Enable support to add extra extension types
              require.extensions = Module._extensions;
              require.registerExtension = function() {
                throw new Error('require.registerExtension() removed. Use ' + 'require.extensions instead.');
              };

              require.cache = Module._cache;

              var dirname = path.dirname(filename);

              if (Module._contextLoad) {
                if (self.id !== '.') {
                  debug('load submodule');
                  // not root module
                  var sandbox = {};
                  for (var k in global) {
                    sandbox[k] = global[k];
                  }
                  sandbox.require = require;
                  sandbox.exports = self.exports;
                  sandbox.__filename = filename;
                  sandbox.__dirname = dirname;
                  sandbox.module = self;
                  sandbox.global = sandbox;
                  sandbox.root = root;

                  return runInNewContext(content, sandbox, filename, true);
                }

                debug('load root module');
                // root module
                global.require = require;
                global.exports = self.exports;
                global.__filename = filename;
                global.__dirname = dirname;
                global.module = self;

                return runInThisContext(content, filename, true);
              }

              // create wrapper function
              var wrapper = Module.wrap(content);

              var compiledWrapper = runInThisContext(wrapper, filename, true);
              if (global.v8debug) {
                if (!resolvedArgv) {
                  // we enter the repl if we're not given a filename argument.
                  if (process.argv[1]) {
                    resolvedArg = Module._resolveFilename(process.argv[1], null);
                  } else {
                    resolvedArg = 'repl';
                  }
                }

                // Set breakpoint on module start
                if (filename === resolvedArgv) {
                  global.v8debug.Debug.setBreakPoint(compiledWrapper, 0, 0);
                }
              }
              var args = [self.exports, require, self, filename, dirname];
              return compiledWrapper.apply(self.exports, args);
            };


            function stripBOM(content) {
              // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
              // because the buffer-to-string conversion in `fs.readFileSync()`
              // translates it to FEFF, the UTF-16 BOM.
              if (content.charCodeAt(0) === 0xFEFF) {
                content = content.slice(1);
              }
              return content;
            }


            // Native extension for .js
            Module._extensions['.js'] = function(module, filename) {
              var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
              module._compile(stripBOM(content), filename);
            };

            // We've already pre-compiled the CoffeeScript so we can embed the source and
            // have it show up in the debugger
            Module._extensions['.coffee'] = Module._extensions['.js']


            // Native extension for .json
            Module._extensions['.json'] = function(module, filename) {
              var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
              try {
                module.exports = JSON.parse(stripBOM(content));
              } catch (err) {
                err.message = filename + ': ' + err.message;
                throw err;
              }
            };


            //Native extension for .node
            Module._extensions['.node'] = function(module, filename) {
              process.dlopen(filename, module.exports);
            };


            // bootstrap main module.
            Module.runMain = function() {
              // Load the main module--the command line argument.
              Module._load(process.argv[1], null, true);
            };

            Module._initPaths = function() {
              var paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];

              if (process.env['HOME']) {
                paths.unshift(path.resolve(process.env['HOME'], '.node_libraries'));
                paths.unshift(path.resolve(process.env['HOME'], '.node_modules'));
              }

              if (process.env['NODE_PATH']) {
                var splitter = process.platform === 'win32' ? ';' : ':';
                paths = process.env['NODE_PATH'].split(splitter).concat(paths);
              }

              modulePaths = paths;

              // clone as a read-only copy, for introspection.
              Module.globalPaths = modulePaths.slice(0);
            };

            // bootstrap repl
            Module.requireRepl = function() {
              return Module._load('repl', '.');
            };

            Module._initPaths();

            // backwards compatibility
            Module.Module = Module;

          },

          "ddeff58ff67e5d2d686891fc66ebb2b7": // from: 
          function(exports, require, module, __filename, __dirname) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            var formatRegExp = /%[sdj%]/g;
            exports.format = function(f) {
              if (typeof f !== 'string') {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
              }

              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                case '%s':
                  return String(args[i++]);
                case '%d':
                  return Number(args[i++]);
                case '%j':
                  return JSON.stringify(args[i++]);
                default:
                  return x;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (x === null || typeof x !== 'object') {
                  str += ' ' + x;
                } else {
                  str += ' ' + inspect(x);
                }
              }
              return str;
            };


            // Mark that a method should not be used.
            // Returns a modified function which warns once by default.
            // If --no-deprecation is set, then it is a no-op.
            exports.deprecate = function(fn, msg) {
              if (process.noDeprecation === true) {
                return fn;
              }

              var warned = false;

              function deprecated() {
                if (!warned) {
                  if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }

              return deprecated;
            };


            exports.print = function() {
              for (var i = 0, len = arguments.length; i < len; ++i) {
                process.stdout.write(String(arguments[i]));
              }
            };


            exports.puts = function() {
              for (var i = 0, len = arguments.length; i < len; ++i) {
                process.stdout.write(arguments[i] + '\n');
              }
            };


            exports.debug = function(x) {
              process.stderr.write('DEBUG: ' + x + '\n');
            };


            var error = exports.error = function(x) {
              for (var i = 0, len = arguments.length; i < len; ++i) {
                process.stderr.write(arguments[i] + '\n');
              }
            };


            /**
             * Echos the value of a value. Trys to print the value out
             * in the best way possible given the different types.
             *
             * @param {Object} obj The object to print out.
             * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
             *    properties of objects.
             * @param {Number} depth Depth in which to descend in object. Default is 2.
             * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
             *    output. Default is false (no coloring).
             */
            function inspect(obj, showHidden, depth, colors) {
              var ctx = {
                showHidden: showHidden,
                seen: [],
                stylize: colors ? stylizeWithColor : stylizeNoColor
              };
              return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
            }
            exports.inspect = inspect;


            // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
            inspect.colors = {
              'bold': [1, 22],
              'italic': [3, 23],
              'underline': [4, 24],
              'inverse': [7, 27],
              'white': [37, 39],
              'grey': [90, 39],
              'black': [30, 39],
              'blue': [34, 39],
              'cyan': [36, 39],
              'green': [32, 39],
              'magenta': [35, 39],
              'red': [31, 39],
              'yellow': [33, 39]
            };

            // Don't use 'blue' not visible on cmd.exe
            inspect.styles = {
              'special': 'cyan',
              'number': 'yellow',
              'boolean': 'yellow',
              'undefined': 'grey',
              'null': 'bold',
              'string': 'green',
              'date': 'magenta',
              // "name": intentionally not styling
              'regexp': 'red'
            };


            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];

              if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
              } else {
                return str;
              }
            }


            function stylizeNoColor(str, styleType) {
              return str;
            }


            function arrayToHash(array) {
              var hash = {};

              array.forEach(function(val, idx) {
                hash[val] = true;
              });

              return hash;
            }


            function formatValue(ctx, value, recurseTimes) {
              // Provide a hook for user-specified inspect functions.
              // Check that value is an object with an inspect function on it
              if (value && typeof value.inspect === 'function' &&
              // Filter out the util module, it's inspect function is special
              value.inspect !== exports.inspect &&
              // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
                return String(value.inspect(recurseTimes));
              }

              // Primitive types cannot have properties
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }

              // Look up the keys of the object.
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);

              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }

              // Some type of object without properties can be shortcutted.
              if (keys.length === 0) {
                if (typeof value === 'function') {
                  var name = value.name ? ': ' + value.name : '';
                  return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }

              var base = '',
                array = false,
                braces = ['{', '}'];

              // Make Array say that they are Array
              if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
              }

              // Make functions say that they are functions
              if (typeof value === 'function') {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
              }

              // Make RegExps say that they are RegExps
              if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
              }

              // Make dates with properties first say the date
              if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
              }

              // Make error with message first say the error
              if (isError(value)) {
                base = ' ' + formatError(value);
              }

              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }

              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                  return ctx.stylize('[Object]', 'special');
                }
              }

              ctx.seen.push(value);

              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }

              ctx.seen.pop();

              return reduceToSingleString(output, base, braces);
            }


            function formatPrimitive(ctx, value) {
              switch (typeof value) {
              case 'undefined':
                return ctx.stylize('undefined', 'undefined');

              case 'string':
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');

              case 'number':
                return ctx.stylize('' + value, 'number');

              case 'boolean':
                return ctx.stylize('' + value, 'boolean');
              }
              // For some reason typeof null is "object", so special case here.
              if (value === null) {
                return ctx.stylize('null', 'null');
              }
            }


            function formatError(value) {
              return '[' + Error.prototype.toString.call(value) + ']';
            }


            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                  String(i), true));
                } else {
                  output.push('');
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                  key, true));
                }
              });
              return output;
            }


            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key]
              };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                  str = ctx.stylize('[Getter]', 'special');
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize('[Setter]', 'special');
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (recurseTimes === null) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf('\n') > -1) {
                    if (array) {
                      str = str.split('\n').map(function(line) {
                        return '  ' + line;
                      }).join('\n').substr(2);
                    } else {
                      str = '\n' + str.split('\n').map(function(line) {
                        return '   ' + line;
                      }).join('\n');
                    }
                  }
                } else {
                  str = ctx.stylize('[Circular]', 'special');
                }
              }
              if (typeof name === 'undefined') {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, 'name');
                } else {
                  name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, 'string');
                }
              }

              return name + ': ' + str;
            }


            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0) numLinesEst++;
                return prev + cur.length + 1;
              }, 0);

              if (length > 60) {
                return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
              }

              return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
            }


            // NOTE: These type checking functions intentionally don't use `instanceof`
            // because it is fragile and can be easily faked with `Object.create()`.
            function isArray(ar) {
              return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
            }
            exports.isArray = isArray;


            function isRegExp(re) {
              return typeof re === 'object' && objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;


            function isDate(d) {
              return typeof d === 'object' && objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;


            function isError(e) {
              return typeof e === 'object' && objectToString(e) === '[object Error]';
            }
            exports.isError = isError;


            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }


            exports.p = exports.deprecate(function() {
              for (var i = 0, len = arguments.length; i < len; ++i) {
                error(exports.inspect(arguments[i]));
              }
            }, 'util.p: Use console.error() instead.');


            function pad(n) {
              return n < 10 ? '0' + n.toString(10) : n.toString(10);
            }


            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // 26 Feb 16:19:34
            function timestamp() {
              var d = new Date();
              var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
              return [d.getDate(), months[d.getMonth()], time].join(' ');
            }


            exports.log = function(msg) {
              exports.puts(timestamp() + ' - ' + msg.toString());
            };


            exports.exec = exports.deprecate(function() {
              return require('child_process').exec.apply(this, arguments);
            }, 'util.exec is now called `child_process.exec`.');


            function pump(readStream, writeStream, callback) {
              var callbackCalled = false;

              function call(a, b, c) {
                if (callback && !callbackCalled) {
                  callback(a, b, c);
                  callbackCalled = true;
                }
              }

              readStream.addListener('data', function(chunk) {
                if (writeStream.write(chunk) === false) readStream.pause();
              });

              writeStream.addListener('drain', function() {
                readStream.resume();
              });

              readStream.addListener('end', function() {
                writeStream.end();
              });

              readStream.addListener('close', function() {
                call();
              });

              readStream.addListener('error', function(err) {
                writeStream.end();
                call(err);
              });

              writeStream.addListener('error', function(err) {
                readStream.destroy();
                call(err);
              });
            }
            exports.pump = exports.deprecate(pump, 'util.pump() is deprecated. Use ReadableStream.prototype.pump() instead.');


            /**
             * Inherit the prototype methods from one constructor into another.
             *
             * The Function.prototype.inherits from lang.js rewritten as a standalone
             * function (not on Function.prototype). NOTE: If this file is to be loaded
             * during bootstrapping this function needs to be rewritten using some native
             * functions as prototype setup using normal JavaScript does not work as
             * expected during bootstrapping (see mirror.js in r114903).
             *
             * @param {function} ctor Constructor function which needs to inherit the
             *     prototype.
             * @param {function} superCtor Constructor function to inherit prototype from.
             */
            exports.inherits = function(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            };

            exports._extend = function(origin, add) {
              // Don't do anything if add isn't an object
              if (!add || typeof add !== 'object') return origin;

              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };

            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }

          },

          "7b51c3f0555ccb0c0f1fcd91d389ea1a": // from: 
          function(exports, require, module, __filename, __dirname) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.


            var isWindows = process.platform === 'win32';
            var util = require('util');


            // resolves . and .. elements in a path array with directory names there
            // must be no slashes, empty elements, or device names (c:\) in the array
            // (so also no leading and trailing slashes - it does not distinguish
            // relative and absolute paths)
            function normalizeArray(parts, allowAboveRoot) {
              // if the path tries to go above the root, `up` ends up > 0
              var up = 0;
              for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === '.') {
                  parts.splice(i, 1);
                } else if (last === '..') {
                  parts.splice(i, 1);
                  up++;
                } else if (up) {
                  parts.splice(i, 1);
                  up--;
                }
              }

              // if the path is allowed to go above the root, restore leading ..s
              if (allowAboveRoot) {
                for (; up--; up) {
                  parts.unshift('..');
                }
              }

              return parts;
            }


            if (isWindows) {
              // Regex to split a windows path into three parts: [*, device, slash,
              // tail] windows-only
              var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?([\\\/])?([\s\S]*?)$/;

              // Regex to split the tail part of the above into [*, dir, basename, ext]
              var splitTailRe = /^([\s\S]+[\\\/](?!$)|[\\\/])?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/\\]*)?)$/;

              // Function to split a filename into [root, dir, basename, ext]
              // windows version
              var splitPath = function(filename) {
                // Separate device+slash from tail
                var result = splitDeviceRe.exec(filename),
                  device = (result[1] || '') + (result[2] || ''),
                  tail = result[3] || '';
                // Split the tail into dir, basename and extension
                var result2 = splitTailRe.exec(tail),
                  dir = result2[1] || '',
                  basename = result2[2] || '',
                  ext = result2[3] || '';
                return [device, dir, basename, ext];
              };

              // path.resolve([from ...], to)
              // windows version
              exports.resolve = function() {
                var resolvedDevice = '',
                  resolvedTail = '',
                  resolvedAbsolute = false;

                for (var i = arguments.length - 1; i >= -1; i--) {
                  var path;
                  if (i >= 0) {
                    path = arguments[i];
                  } else if (!resolvedDevice) {
                    path = process.cwd();
                  } else {
                    // Windows has the concept of drive-specific current working
                    // directories. If we've resolved a drive letter but not yet an
                    // absolute path, get cwd for that drive. We're sure the device is not
                    // an unc path at this points, because unc paths are always absolute.
                    path = process.env['=' + resolvedDevice];
                    // Verify that a drive-local cwd was found and that it actually points
                    // to our drive. If not, default to the drive's root.
                    if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
                      path = resolvedDevice + '\\';
                    }
                  }

                  // Skip empty and invalid entries
                  if (typeof path !== 'string' || !path) {
                    continue;
                  }

                  var result = splitDeviceRe.exec(path),
                    device = result[1] || '',
                    isUnc = device && device.charAt(1) !== ':',
                    isAbsolute = !! result[2] || isUnc, // UNC paths are always absolute
                    tail = result[3];

                  if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                    // This path points to another device so it is not applicable
                    continue;
                  }

                  if (!resolvedDevice) {
                    resolvedDevice = device;
                  }
                  if (!resolvedAbsolute) {
                    resolvedTail = tail + '\\' + resolvedTail;
                    resolvedAbsolute = isAbsolute;
                  }

                  if (resolvedDevice && resolvedAbsolute) {
                    break;
                  }
                }

                // Replace slashes (in UNC share name) by backslashes
                resolvedDevice = resolvedDevice.replace(/\//g, '\\');

                // At this point the path should be resolved to a full absolute path,
                // but handle relative paths to be safe (might happen when process.cwd()
                // fails)

                // Normalize the tail path

                function f(p) {
                  return !!p;
                }

                resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f), !resolvedAbsolute).join('\\');

                return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) || '.';
              };

              // windows version
              exports.normalize = function(path) {
                var result = splitDeviceRe.exec(path),
                  device = result[1] || '',
                  isUnc = device && device.charAt(1) !== ':',
                  isAbsolute = !! result[2] || isUnc, // UNC paths are always absolute
                  tail = result[3],
                  trailingSlash = /[\\\/]$/.test(tail);

                // Normalize the tail path
                tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
                  return !!p;
                }), !isAbsolute).join('\\');

                if (!tail && !isAbsolute) {
                  tail = '.';
                }
                if (tail && trailingSlash) {
                  tail += '\\';
                }

                // Convert slashes to backslashes when `device` points to an UNC root.
                device = device.replace(/\//g, '\\');

                return device + (isAbsolute ? '\\' : '') + tail;
              };

              // windows version
              exports.join = function() {
                function f(p) {
                  return p && typeof p === 'string';
                }

                var paths = Array.prototype.filter.call(arguments, f);
                var joined = paths.join('\\');

                // Make sure that the joined path doesn't start with two slashes
                // - it will be mistaken for an unc path by normalize() -
                // unless the paths[0] also starts with two slashes
                if (/^[\\\/]{2}/.test(joined) && !/^[\\\/]{2}/.test(paths[0])) {
                  joined = joined.substr(1);
                }

                return exports.normalize(joined);
              };

              // path.relative(from, to)
              // it will solve the relative path from 'from' to 'to', for instance:
              // from = 'C:\\orandea\\test\\aaa'
              // to = 'C:\\orandea\\impl\\bbb'
              // The output of the function should be: '..\\..\\impl\\bbb'
              // windows version
              exports.relative = function(from, to) {
                from = exports.resolve(from);
                to = exports.resolve(to);

                // windows is not case sensitive
                var lowerFrom = from.toLowerCase();
                var lowerTo = to.toLowerCase();

                function trim(arr) {
                  var start = 0;
                  for (; start < arr.length; start++) {
                    if (arr[start] !== '') break;
                  }

                  var end = arr.length - 1;
                  for (; end >= 0; end--) {
                    if (arr[end] !== '') break;
                  }

                  if (start > end) return [];
                  return arr.slice(start, end - start + 1);
                }

                var toParts = trim(to.split('\\'));

                var lowerFromParts = trim(lowerFrom.split('\\'));
                var lowerToParts = trim(lowerTo.split('\\'));

                var length = Math.min(lowerFromParts.length, lowerToParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                  if (lowerFromParts[i] !== lowerToParts[i]) {
                    samePartsLength = i;
                    break;
                  }
                }

                if (samePartsLength == 0) {
                  return to;
                }

                var outputParts = [];
                for (var i = samePartsLength; i < lowerFromParts.length; i++) {
                  outputParts.push('..');
                }

                outputParts = outputParts.concat(toParts.slice(samePartsLength));

                return outputParts.join('\\');
              };

              exports.sep = '\\';

            } else /* posix */
            {

              // Split a filename into [root, dir, basename, ext], unix version
              // 'root' is just a slash, or nothing.
              var splitPathRe = /^(\/?)([\s\S]+\/(?!$)|\/)?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/]*)?)$/;
              var splitPath = function(filename) {
                var result = splitPathRe.exec(filename);
                return [result[1] || '', result[2] || '', result[3] || '', result[4] || ''];
              };

              // path.resolve([from ...], to)
              // posix version
              exports.resolve = function() {
                var resolvedPath = '',
                  resolvedAbsolute = false;

                for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                  var path = (i >= 0) ? arguments[i] : process.cwd();

                  // Skip empty and invalid entries
                  if (typeof path !== 'string' || !path) {
                    continue;
                  }

                  resolvedPath = path + '/' + resolvedPath;
                  resolvedAbsolute = path.charAt(0) === '/';
                }

                // At this point the path should be resolved to a full absolute path, but
                // handle relative paths to be safe (might happen when process.cwd() fails)

                // Normalize the path
                resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
                  return !!p;
                }), !resolvedAbsolute).join('/');

                return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
              };

              // path.normalize(path)
              // posix version
              exports.normalize = function(path) {
                var isAbsolute = path.charAt(0) === '/',
                  trailingSlash = path.substr(-1) === '/';

                // Normalize the path
                path = normalizeArray(path.split('/').filter(function(p) {
                  return !!p;
                }), !isAbsolute).join('/');

                if (!path && !isAbsolute) {
                  path = '.';
                }
                if (path && trailingSlash) {
                  path += '/';
                }

                return (isAbsolute ? '/' : '') + path;
              };


              // posix version
              exports.join = function() {
                var paths = Array.prototype.slice.call(arguments, 0);
                return exports.normalize(paths.filter(function(p, index) {
                  return p && typeof p === 'string';
                }).join('/'));
              };


              // path.relative(from, to)
              // posix version
              exports.relative = function(from, to) {
                from = exports.resolve(from).substr(1);
                to = exports.resolve(to).substr(1);

                function trim(arr) {
                  var start = 0;
                  for (; start < arr.length; start++) {
                    if (arr[start] !== '') break;
                  }

                  var end = arr.length - 1;
                  for (; end >= 0; end--) {
                    if (arr[end] !== '') break;
                  }

                  if (start > end) return [];
                  return arr.slice(start, end - start + 1);
                }

                var fromParts = trim(from.split('/'));
                var toParts = trim(to.split('/'));

                var length = Math.min(fromParts.length, toParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                  if (fromParts[i] !== toParts[i]) {
                    samePartsLength = i;
                    break;
                  }
                }

                var outputParts = [];
                for (var i = samePartsLength; i < fromParts.length; i++) {
                  outputParts.push('..');
                }

                outputParts = outputParts.concat(toParts.slice(samePartsLength));

                return outputParts.join('/');
              };

              exports.sep = '/';
            }


            exports.dirname = function(path) {
              var result = splitPath(path),
                root = result[0],
                dir = result[1];

              if (!root && !dir) {
                // No dirname whatsoever
                return '.';
              }

              if (dir) {
                // It has a dirname, strip trailing slash
                dir = dir.substr(0, dir.length - 1);
              }

              return root + dir;
            };


            exports.basename = function(path, ext) {
              var f = splitPath(path)[2];
              // TODO: make this comparison case-insensitive on windows?
              if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length);
              }
              return f;
            };


            exports.extname = function(path) {
              return splitPath(path)[3];
            };


            exports.exists = util.deprecate(function(path, callback) {
              require('fs').exists(path, callback);
            }, 'path.exists is now called `fs.exists`.');


            exports.existsSync = util.deprecate(function(path) {
              return require('fs').existsSync(path);
            }, 'path.existsSync is now called `fs.existsSync`.');


            if (isWindows) {
              exports._makeLong = function(path) {
                path = '' + path;
                if (!path) {
                  return '';
                }

                var resolvedPath = exports.resolve(path);

                if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
                  // path is local filesystem path, which needs to be converted
                  // to long UNC path.
                  return '\\\\?\\' + resolvedPath;
                } else if (/^\\\\[^?.]/.test(resolvedPath)) {
                  // path is network UNC path, which needs to be converted
                  // to long UNC path.
                  return '\\\\?\\UNC\\' + resolvedPath.substring(2);
                }

                return path;
              };
            } else {
              exports._makeLong = function(path) {
                return path;
              };
            }

          },

          "d0c9d6cc2490c964b789d43ae4803b7b": // from: 
          function(exports, require, module, __filename, __dirname) {
            var punycode = {
              encode: function(s) {
                return s
              }
            };

            exports.parse = urlParse;
            exports.resolve = urlResolve;
            exports.resolveObject = urlResolveObject;
            exports.format = urlFormat;

            function arrayIndexOf(array, subject) {
              for (var i = 0, j = array.length; i < j; i++) {
                if (array[i] == subject) return i;
              }
              return -1;
            }

            var objectKeys = Object.keys || function objectKeys(object) {
                if (object !== Object(object)) throw new TypeError('Invalid object');
                var keys = [];
                for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
                return keys;
              }

              // Reference: RFC 3986, RFC 1808, RFC 2396

              // define these here so at least they only have to be
              // compiled once on the first module load.
            var protocolPattern = /^([a-z0-9.+-]+:)/i,
              portPattern = /:[0-9]+$/,
              // RFC 2396: characters reserved for delimiting URLs.
              delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
              // RFC 2396: characters not allowed for various reasons.
              unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
              // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
              autoEscape = ['\''],
              // Characters that are never ever allowed in a hostname.
              // Note that any invalid chars are also handled, but these
              // are the ones that are *expected* to be seen, so we fast-path
              // them.
              nonHostChars = ['%', '/', '?', ';', '#'].concat(unwise).concat(autoEscape),
              nonAuthChars = ['/', '@', '?', '#'].concat(delims),
              hostnameMaxLen = 255,
              hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
              hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
              // protocols that can allow "unsafe" and "unwise" chars.
              unsafeProtocol = {
                'javascript': true,
                'javascript:': true
              },
              // protocols that never have a hostname.
              hostlessProtocol = {
                'javascript': true,
                'javascript:': true
              },
              // protocols that always have a path component.
              pathedProtocol = {
                'http': true,
                'https': true,
                'ftp': true,
                'gopher': true,
                'file': true,
                'http:': true,
                'ftp:': true,
                'gopher:': true,
                'file:': true
              },
              // protocols that always contain a // bit.
              slashedProtocol = {
                'http': true,
                'https': true,
                'ftp': true,
                'gopher': true,
                'file': true,
                'http:': true,
                'https:': true,
                'ftp:': true,
                'gopher:': true,
                'file:': true
              },
              querystring = require('querystring');

            function urlParse(url, parseQueryString, slashesDenoteHost) {
              if (url && typeof(url) === 'object' && url.href) return url;

              if (typeof url !== 'string') {
                throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
              }

              var out = {},
              rest = url;

              // cut off any delimiters.
              // This is to support parse stuff like "<http://foo.com>"
              for (var i = 0, l = rest.length; i < l; i++) {
                if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
              }
              if (i !== 0) rest = rest.substr(i);


              var proto = protocolPattern.exec(rest);
              if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                out.protocol = lowerProto;
                rest = rest.substr(proto.length);
              }

              // figure out if it's got a host
              // user@server is *always* interpreted as a hostname, and url
              // resolution will treat //foo/bar as host=foo,path=bar because that's
              // how the browser resolves relative URLs.
              if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = rest.substr(0, 2) === '//';
                if (slashes && !(proto && hostlessProtocol[proto])) {
                  rest = rest.substr(2);
                  out.slashes = true;
                }
              }

              if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
                // there's a hostname.
                // the first instance of /, ?, ;, or # ends the host.
                // don't enforce full RFC correctness, just be unstupid about it.

                // If there is an @ in the hostname, then non-host chars *are* allowed
                // to the left of the first @ sign, unless some non-auth character
                // comes *before* the @-sign.
                // URLs are obnoxious.
                var atSign = arrayIndexOf(rest, '@');
                if (atSign !== -1) {
                  // there *may be* an auth
                  var hasAuth = true;
                  for (var i = 0, l = nonAuthChars.length; i < l; i++) {
                    var index = arrayIndexOf(rest, nonAuthChars[i]);
                    if (index !== -1 && index < atSign) {
                      // not a valid auth.  Something like http://foo.com/bar@baz/
                      hasAuth = false;
                      break;
                    }
                  }
                  if (hasAuth) {
                    // pluck off the auth portion.
                    out.auth = rest.substr(0, atSign);
                    rest = rest.substr(atSign + 1);
                  }
                }

                var firstNonHost = -1;
                for (var i = 0, l = nonHostChars.length; i < l; i++) {
                  var index = arrayIndexOf(rest, nonHostChars[i]);
                  if (index !== -1 && (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
                }

                if (firstNonHost !== -1) {
                  out.host = rest.substr(0, firstNonHost);
                  rest = rest.substr(firstNonHost);
                } else {
                  out.host = rest;
                  rest = '';
                }

                // pull out port.
                var p = parseHost(out.host);
                var keys = objectKeys(p);
                for (var i = 0, l = keys.length; i < l; i++) {
                  var key = keys[i];
                  out[key] = p[key];
                }

                // we've indicated that there is a hostname,
                // so even if it's empty, it has to be present.
                out.hostname = out.hostname || '';

                // validate a little.
                if (out.hostname.length > hostnameMaxLen) {
                  out.hostname = '';
                } else {
                  var hostparts = out.hostname.split(/\./);
                  for (var i = 0, l = hostparts.length; i < l; i++) {
                    var part = hostparts[i];
                    if (!part) continue;
                    if (!part.match(hostnamePartPattern)) {
                      var newpart = '';
                      for (var j = 0, k = part.length; j < k; j++) {
                        if (part.charCodeAt(j) > 127) {
                          // we replace non-ASCII char with a temporary placeholder
                          // we need this to make sure size of hostname is not
                          // broken by replacing non-ASCII by nothing
                          newpart += 'x';
                        } else {
                          newpart += part[j];
                        }
                      }
                      // we test again with ASCII char only
                      if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                          validParts.push(bit[1]);
                          notHost.unshift(bit[2]);
                        }
                        if (notHost.length) {
                          rest = '/' + notHost.join('.') + rest;
                        }
                        out.hostname = validParts.join('.');
                        break;
                      }
                    }
                  }
                }

                // hostnames are always lower case.
                out.hostname = out.hostname.toLowerCase();

                // IDNA Support: Returns a puny coded representation of "domain".
                // It only converts the part of the domain name that
                // has non ASCII characters. I.e. it dosent matter if
                // you call it with a domain that already is in ASCII.
                var domainArray = out.hostname.split('.');
                var newOut = [];
                for (var i = 0; i < domainArray.length; ++i) {
                  var s = domainArray[i];
                  newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
                }
                out.hostname = newOut.join('.');

                out.host = (out.hostname || '') + ((out.port) ? ':' + out.port : '');
                out.href += out.host;
              }

              // now rest is set to the post-host stuff.
              // chop off any delim chars.
              if (!unsafeProtocol[lowerProto]) {

                // First, make 100% sure that any "autoEscape" chars get
                // escaped, even if encodeURIComponent doesn't think they
                // need to be.
                for (var i = 0, l = autoEscape.length; i < l; i++) {
                  var ae = autoEscape[i];
                  var esc = encodeURIComponent(ae);
                  if (esc === ae) {
                    esc = escape(ae);
                  }
                  rest = rest.split(ae).join(esc);
                }

                // Now make sure that delims never appear in a url.
                var chop = rest.length;
                for (var i = 0, l = delims.length; i < l; i++) {
                  var c = arrayIndexOf(rest, delims[i]);
                  if (c !== -1) {
                    chop = Math.min(c, chop);
                  }
                }
                rest = rest.substr(0, chop);
              }


              // chop off from the tail first.
              var hash = arrayIndexOf(rest, '#');
              if (hash !== -1) {
                // got a fragment string.
                out.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
              }
              var qm = arrayIndexOf(rest, '?');
              if (qm !== -1) {
                out.search = rest.substr(qm);
                out.query = rest.substr(qm + 1);
                if (parseQueryString) {
                  out.query = querystring.parse(out.query);
                }
                rest = rest.slice(0, qm);
              } else if (parseQueryString) {
                // no query string, but parseQueryString still requested
                out.search = '';
                out.query = {};
              }
              if (rest) out.pathname = rest;
              if (slashedProtocol[proto] && out.hostname && !out.pathname) {
                out.pathname = '/';
              }

              //to support http.request
              if (out.pathname || out.search) {
                out.path = (out.pathname ? out.pathname : '') + (out.search ? out.search : '');
              }

              // finally, reconstruct the href based on what has been validated.
              out.href = urlFormat(out);
              return out;
            }

            // format a parsed object into a url string
            function urlFormat(obj) {
              // ensure it's an object, and not a string url.
              // If it's an obj, this is a no-op.
              // this way, you can call url_format() on strings
              // to clean up potentially wonky urls.
              if (typeof(obj) === 'string') obj = urlParse(obj);

              var auth = obj.auth || '';
              if (auth) {
                auth = auth.split('@').join('%40');
                for (var i = 0, l = nonAuthChars.length; i < l; i++) {
                  var nAC = nonAuthChars[i];
                  auth = auth.split(nAC).join(encodeURIComponent(nAC));
                }
                auth += '@';
              }

              var protocol = obj.protocol || '',
                host = (obj.host !== undefined) ? auth + obj.host : obj.hostname !== undefined ? (
                auth + obj.hostname + (obj.port ? ':' + obj.port : '')) : false,
                pathname = obj.pathname || '',
                query = obj.query && ((typeof obj.query === 'object' && objectKeys(obj.query).length) ? querystring.stringify(obj.query) : '') || '',
                search = obj.search || (query && ('?' + query)) || '',
                hash = obj.hash || '';

              if (protocol && protocol.substr(-1) !== ':') protocol += ':';

              // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
              // unless they had them to begin with.
              if (obj.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
                host = '//' + (host || '');
                if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
              } else if (!host) {
                host = '';
              }

              if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
              if (search && search.charAt(0) !== '?') search = '?' + search;

              return protocol + host + pathname + search + hash;
            }

            function urlResolve(source, relative) {
              return urlFormat(urlResolveObject(source, relative));
            }

            function urlResolveObject(source, relative) {
              if (!source) return relative;

              source = urlParse(urlFormat(source), false, true);
              relative = urlParse(urlFormat(relative), false, true);

              // hash is always overridden, no matter what.
              source.hash = relative.hash;

              if (relative.href === '') {
                source.href = urlFormat(source);
                return source;
              }

              // hrefs like //foo/bar always cut to the protocol.
              if (relative.slashes && !relative.protocol) {
                relative.protocol = source.protocol;
                //urlParse appends trailing / to urls like http://www.example.com
                if (slashedProtocol[relative.protocol] && relative.hostname && !relative.pathname) {
                  relative.path = relative.pathname = '/';
                }
                relative.href = urlFormat(relative);
                return relative;
              }

              if (relative.protocol && relative.protocol !== source.protocol) {
                // if it's a known url protocol, then changing
                // the protocol does weird things
                // first, if it's not file:, then we MUST have a host,
                // and if there was a path
                // to begin with, then we MUST have a path.
                // if it is file:, then the host is dropped,
                // because that's known to be hostless.
                // anything else is assumed to be absolute.
                if (!slashedProtocol[relative.protocol]) {
                  relative.href = urlFormat(relative);
                  return relative;
                }
                source.protocol = relative.protocol;
                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                  var relPath = (relative.pathname || '').split('/');
                  while (relPath.length && !(relative.host = relPath.shift()));
                  if (!relative.host) relative.host = '';
                  if (!relative.hostname) relative.hostname = '';
                  if (relPath[0] !== '') relPath.unshift('');
                  if (relPath.length < 2) relPath.unshift('');
                  relative.pathname = relPath.join('/');
                }
                source.pathname = relative.pathname;
                source.search = relative.search;
                source.query = relative.query;
                source.host = relative.host || '';
                source.auth = relative.auth;
                source.hostname = relative.hostname || relative.host;
                source.port = relative.port;
                //to support http.request
                if (source.pathname !== undefined || source.search !== undefined) {
                  source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
                }
                source.slashes = source.slashes || relative.slashes;
                source.href = urlFormat(source);
                return source;
              }

              var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
                isRelAbs = (
                relative.host !== undefined || relative.pathname && relative.pathname.charAt(0) === '/'),
                mustEndAbs = (isRelAbs || isSourceAbs || (source.host && relative.pathname)),
                removeAllDots = mustEndAbs,
                srcPath = source.pathname && source.pathname.split('/') || [],
                relPath = relative.pathname && relative.pathname.split('/') || [],
                psychotic = source.protocol && !slashedProtocol[source.protocol];

              // if the url is a non-slashed url, then relative
              // links like ../.. should be able
              // to crawl up to the hostname, as well.  This is strange.
              // source.protocol has already been set by now.
              // Later on, put the first path part into the host field.
              if (psychotic) {

                delete source.hostname;
                delete source.port;
                if (source.host) {
                  if (srcPath[0] === '') srcPath[0] = source.host;
                  else srcPath.unshift(source.host);
                }
                delete source.host;
                if (relative.protocol) {
                  delete relative.hostname;
                  delete relative.port;
                  if (relative.host) {
                    if (relPath[0] === '') relPath[0] = relative.host;
                    else relPath.unshift(relative.host);
                  }
                  delete relative.host;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
              }

              if (isRelAbs) {
                // it's absolute.
                source.host = (relative.host || relative.host === '') ? relative.host : source.host;
                source.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : source.hostname;
                source.search = relative.search;
                source.query = relative.query;
                srcPath = relPath;
                // fall through to the dot-handling below.
              } else if (relPath.length) {
                // it's relative
                // throw away the existing file, and take the new path instead.
                if (!srcPath) srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                source.search = relative.search;
                source.query = relative.query;
              } else if ('search' in relative) {
                // just pull out the search.
                // like href='?foo'.
                // Put this after the other two cases because it simplifies the booleans
                if (psychotic) {
                  source.hostname = source.host = srcPath.shift();
                  //occationaly the auth can get stuck only in host
                  //this especialy happens in cases like
                  //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                  var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ? source.host.split('@') : false;
                  if (authInHost) {
                    source.auth = authInHost.shift();
                    source.host = source.hostname = authInHost.shift();
                  }
                }
                source.search = relative.search;
                source.query = relative.query;
                //to support http.request
                if (source.pathname !== undefined || source.search !== undefined) {
                  source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
                }
                source.href = urlFormat(source);
                return source;
              }
              if (!srcPath.length) {
                // no path at all.  easy.
                // we've already handled the other stuff above.
                delete source.pathname;
                //to support http.request
                if (!source.search) {
                  source.path = '/' + source.search;
                } else {
                  delete source.path;
                }
                source.href = urlFormat(source);
                return source;
              }
              // if a url ENDs in . or .., then it must get a trailing slash.
              // however, if it ends in anything else non-slashy,
              // then it must NOT get a trailing slash.
              var last = srcPath.slice(-1)[0];
              var hasTrailingSlash = (
              (source.host || relative.host) && (last === '.' || last === '..') || last === '');

              // strip single dots, resolve double dots to parent dir
              // if the path tries to go above the root, `up` ends up > 0
              var up = 0;
              for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last == '.') {
                  srcPath.splice(i, 1);
                } else if (last === '..') {
                  srcPath.splice(i, 1);
                  up++;
                } else if (up) {
                  srcPath.splice(i, 1);
                  up--;
                }
              }

              // if the path is allowed to go above the root, restore leading ..s
              if (!mustEndAbs && !removeAllDots) {
                for (; up--; up) {
                  srcPath.unshift('..');
                }
              }

              if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
                srcPath.unshift('');
              }

              if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
                srcPath.push('');
              }

              var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

              // put the host back
              if (psychotic) {
                source.hostname = source.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
                //occationaly the auth can get stuck only in host
                //this especialy happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ? source.host.split('@') : false;
                if (authInHost) {
                  source.auth = authInHost.shift();
                  source.host = source.hostname = authInHost.shift();
                }
              }

              mustEndAbs = mustEndAbs || (source.host && srcPath.length);

              if (mustEndAbs && !isAbsolute) {
                srcPath.unshift('');
              }

              source.pathname = srcPath.join('/');
              //to support request.http
              if (source.pathname !== undefined || source.search !== undefined) {
                source.path = (source.pathname ? source.pathname : '') + (source.search ? source.search : '');
              }
              source.auth = relative.auth || source.auth;
              source.slashes = source.slashes || relative.slashes;
              source.href = urlFormat(source);
              return source;
            }

            function parseHost(host) {
              var out = {};
              var port = portPattern.exec(host);
              if (port) {
                port = port[0];
                out.port = port.substr(1);
                host = host.substr(0, host.length - port.length);
              }
              if (host) out.hostname = host;
              return out;
            }

          },

          "b499eb63a89b9e6fb99ef1209a65ace6": // from: 
          function(exports, require, module, __filename, __dirname) {
            if (!process.EventEmitter) process.EventEmitter = function() {};

            var EventEmitter = exports.EventEmitter = process.EventEmitter;
            var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
                return Object.prototype.toString.call(xs) === '[object Array]'
              };

            // By default EventEmitters will print a warning if more than
            // 10 listeners are added to it. This is a useful default which
            // helps finding memory leaks.
            //
            // Obviously not all Emitters should be limited to 10. This function allows
            // that to be increased. Set to zero for unlimited.
            var defaultMaxListeners = 10;
            EventEmitter.prototype.setMaxListeners = function(n) {
              if (!this._events) this._events = {};
              this._events.maxListeners = n;
            };


            EventEmitter.prototype.emit = function(type) {
              // If there is no 'error' event listener then throw.
              if (type === 'error') {
                if (!this._events || !this._events.error || (isArray(this._events.error) && !this._events.error.length)) {
                  if (arguments[1] instanceof Error) {
                    throw arguments[1]; // Unhandled 'error' event
                  } else {
                    throw new Error("Uncaught, unspecified 'error' event.");
                  }
                  return false;
                }
              }

              if (!this._events) return false;
              var handler = this._events[type];
              if (!handler) return false;

              if (typeof handler == 'function') {
                switch (arguments.length) {
                  // fast cases
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                  // slower
                default:
                  var args = Array.prototype.slice.call(arguments, 1);
                  handler.apply(this, args);
                }
                return true;

              } else if (isArray(handler)) {
                var args = Array.prototype.slice.call(arguments, 1);

                var listeners = handler.slice();
                for (var i = 0, l = listeners.length; i < l; i++) {
                  listeners[i].apply(this, args);
                }
                return true;

              } else {
                return false;
              }
            };

            // EventEmitter is defined in src/node_events.cc
            // EventEmitter.prototype.emit() is also defined there.
            EventEmitter.prototype.addListener = function(type, listener) {
              if ('function' !== typeof listener) {
                throw new Error('addListener only takes instances of Function');
              }

              if (!this._events) this._events = {};

              // To avoid recursion in the case that type == "newListeners"! Before
              // adding it to the listeners, first emit "newListeners".
              this.emit('newListener', type, listener);

              if (!this._events[type]) {
                // Optimize the case of one listener. Don't need the extra array object.
                this._events[type] = listener;
              } else if (isArray(this._events[type])) {

                // Check for listener leak
                if (!this._events[type].warned) {
                  var m;
                  if (this._events.maxListeners !== undefined) {
                    m = this._events.maxListeners;
                  } else {
                    m = defaultMaxListeners;
                  }

                  if (m && m > 0 && this._events[type].length > m) {
                    this._events[type].warned = true;
                    console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                    console.trace();
                  }
                }

                // If we've already got an array, just append.
                this._events[type].push(listener);
              } else {
                // Adding the second element, need to change to array.
                this._events[type] = [this._events[type], listener];
              }

              return this;
            };

            EventEmitter.prototype.on = EventEmitter.prototype.addListener;

            EventEmitter.prototype.once = function(type, listener) {
              var self = this;
              self.on(type, function g() {
                self.removeListener(type, g);
                listener.apply(this, arguments);
              });

              return this;
            };

            EventEmitter.prototype.removeListener = function(type, listener) {
              if ('function' !== typeof listener) {
                throw new Error('removeListener only takes instances of Function');
              }

              // does not use listeners(), so no side effect of creating _events[type]
              if (!this._events || !this._events[type]) return this;

              var list = this._events[type];

              if (isArray(list)) {
                var i = list.indexOf(listener);
                if (i < 0) return this;
                list.splice(i, 1);
                if (list.length == 0) delete this._events[type];
              } else if (this._events[type] === listener) {
                delete this._events[type];
              }

              return this;
            };

            EventEmitter.prototype.removeAllListeners = function(type) {
              // does not use listeners(), so no side effect of creating _events[type]
              if (type && this._events && this._events[type]) this._events[type] = null;
              return this;
            };

            EventEmitter.prototype.listeners = function(type) {
              if (!this._events) this._events = {};
              if (!this._events[type]) this._events[type] = [];
              if (!isArray(this._events[type])) {
                this._events[type] = [this._events[type]];
              }
              return this._events[type];
            };

          },

          "54c69a095dc8e4a9173bd8284c4e8ad7": // from: 
          function(exports, require, module, __filename, __dirname) {
            var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(xs) {
                return Object.prototype.toString.call(xs) === '[object Array]'
              };

            var objectKeys = Object.keys || function objectKeys(object) {
                if (object !== Object(object)) throw new TypeError('Invalid object');
                var keys = [];
                for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
                return keys;
              }


              /*!
               * querystring
               * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
               * MIT Licensed
               */

              /**
               * Library version.
               */

              exports.version = '0.3.1';

            /**
             * Object#toString() ref for stringify().
             */

            var toString = Object.prototype.toString;

            /**
             * Cache non-integer test regexp.
             */

            var notint = /[^0-9]/;

            /**
             * Parse the given query `str`, returning an object.
             *
             * @param {String} str
             * @return {Object}
             * @api public
             */

            exports.parse = function(str) {
              if (null == str || '' == str) return {};

              function promote(parent, key) {
                if (parent[key].length == 0) return parent[key] = {};
                var t = {};
                for (var i in parent[key]) t[i] = parent[key][i];
                parent[key] = t;
                return t;
              }

              return String(str).split('&').reduce(function(ret, pair) {
                try {
                  pair = decodeURIComponent(pair.replace(/\+/g, ' '));
                } catch (e) {
                  // ignore
                }

                var eql = pair.indexOf('='),
                  brace = lastBraceInKey(pair),
                  key = pair.substr(0, brace || eql),
                  val = pair.substr(brace || eql, pair.length),
                  val = val.substr(val.indexOf('=') + 1, val.length),
                  parent = ret;

                // ?foo
                if ('' == key) key = pair, val = '';

                // nested
                if (~key.indexOf(']')) {
                  var parts = key.split('['),
                    len = parts.length,
                    last = len - 1;

                  function parse(parts, parent, key) {
                    var part = parts.shift();

                    // end
                    if (!part) {
                      if (isArray(parent[key])) {
                        parent[key].push(val);
                      } else if ('object' == typeof parent[key]) {
                        parent[key] = val;
                      } else if ('undefined' == typeof parent[key]) {
                        parent[key] = val;
                      } else {
                        parent[key] = [parent[key], val];
                      }
                      // array
                    } else {
                      obj = parent[key] = parent[key] || [];
                      if (']' == part) {
                        if (isArray(obj)) {
                          if ('' != val) obj.push(val);
                        } else if ('object' == typeof obj) {
                          obj[objectKeys(obj).length] = val;
                        } else {
                          obj = parent[key] = [parent[key], val];
                        }
                        // prop
                      } else if (~part.indexOf(']')) {
                        part = part.substr(0, part.length - 1);
                        if (notint.test(part) && isArray(obj)) obj = promote(parent, key);
                        parse(parts, obj, part);
                        // key
                      } else {
                        if (notint.test(part) && isArray(obj)) obj = promote(parent, key);
                        parse(parts, obj, part);
                      }
                    }
                  }

                  parse(parts, parent, 'base');
                  // optimize
                } else {
                  if (notint.test(key) && isArray(parent.base)) {
                    var t = {};
                    for (var k in parent.base) t[k] = parent.base[k];
                    parent.base = t;
                  }
                  set(parent.base, key, val);
                }

                return ret;
              }, {
                base: {}
              }).base;
            };

            /**
             * Turn the given `obj` into a query string
             *
             * @param {Object} obj
             * @return {String}
             * @api public
             */

            var stringify = exports.stringify = function(obj, prefix) {
              if (isArray(obj)) {
                return stringifyArray(obj, prefix);
              } else if ('[object Object]' == toString.call(obj)) {
                return stringifyObject(obj, prefix);
              } else if ('string' == typeof obj) {
                return stringifyString(obj, prefix);
              } else {
                return prefix;
              }
            };

            /**
             * Stringify the given `str`.
             *
             * @param {String} str
             * @param {String} prefix
             * @return {String}
             * @api private
             */

            function stringifyString(str, prefix) {
              if (!prefix) throw new TypeError('stringify expects an object');
              return prefix + '=' + encodeURIComponent(str);
            }

            /**
             * Stringify the given `arr`.
             *
             * @param {Array} arr
             * @param {String} prefix
             * @return {String}
             * @api private
             */

            function stringifyArray(arr, prefix) {
              var ret = [];
              if (!prefix) throw new TypeError('stringify expects an object');
              for (var i = 0; i < arr.length; i++) {
                ret.push(stringify(arr[i], prefix + '[]'));
              }
              return ret.join('&');
            }

            /**
             * Stringify the given `obj`.
             *
             * @param {Object} obj
             * @param {String} prefix
             * @return {String}
             * @api private
             */

            function stringifyObject(obj, prefix) {
              var ret = [],
                keys = objectKeys(obj),
                key;
              for (var i = 0, len = keys.length; i < len; ++i) {
                key = keys[i];
                ret.push(stringify(obj[key], prefix ? prefix + '[' + encodeURIComponent(key) + ']' : encodeURIComponent(key)));
              }
              return ret.join('&');
            }

            /**
             * Set `obj`'s `key` to `val` respecting
             * the weird and wonderful syntax of a qs,
             * where "foo=bar&foo=baz" becomes an array.
             *
             * @param {Object} obj
             * @param {String} key
             * @param {String} val
             * @api private
             */

            function set(obj, key, val) {
              var v = obj[key];
              if (undefined === v) {
                obj[key] = val;
              } else if (isArray(v)) {
                v.push(val);
              } else {
                obj[key] = [v, val];
              }
            }

            /**
             * Locate last brace in `str` within the key.
             *
             * @param {String} str
             * @return {Number}
             * @api private
             */

            function lastBraceInKey(str) {
              var len = str.length,
                brace, c;
              for (var i = 0; i < len; ++i) {
                c = str[i];
                if (']' == c) brace = false;
                if ('[' == c) brace = true;
                if ('=' == c && !brace) return i;
              }
            }

          },

          "f0d5935f094eb3d9fb70c67795bd4caf": // from: 
          function(exports, require, module, __filename, __dirname) {
            var events = require('events');
            var util = require('util');

            function Stream() {
              events.EventEmitter.call(this);
            }
            util.inherits(Stream, events.EventEmitter);
            module.exports = Stream;
            // Backwards-compat with node 0.4.x
            Stream.Stream = Stream;

            Stream.prototype.pipe = function(dest, options) {
              var source = this;

              function ondata(chunk) {
                if (dest.writable) {
                  if (false === dest.write(chunk) && source.pause) {
                    source.pause();
                  }
                }
              }

              source.on('data', ondata);

              function ondrain() {
                if (source.readable && source.resume) {
                  source.resume();
                }
              }

              dest.on('drain', ondrain);

              // If the 'end' option is not supplied, dest.end() will be called when
              // source gets the 'end' or 'close' events.  Only dest.end() once, and
              // only when all sources have ended.
              if (!dest._isStdio && (!options || options.end !== false)) {
                dest._pipeCount = dest._pipeCount || 0;
                dest._pipeCount++;

                source.on('end', onend);
                source.on('close', onclose);
              }

              var didOnEnd = false;

              function onend() {
                if (didOnEnd) return;
                didOnEnd = true;

                dest._pipeCount--;

                // remove the listeners
                cleanup();

                if (dest._pipeCount > 0) {
                  // waiting for other incoming streams to end.
                  return;
                }

                dest.end();
              }


              function onclose() {
                if (didOnEnd) return;
                didOnEnd = true;

                dest._pipeCount--;

                // remove the listeners
                cleanup();

                if (dest._pipeCount > 0) {
                  // waiting for other incoming streams to end.
                  return;
                }

                dest.destroy();
              }

              // don't leave dangling pipes when there are errors.
              function onerror(er) {
                cleanup();
                if (this.listeners('error').length === 0) {
                  throw er; // Unhandled stream error in pipe.
                }
              }

              source.on('error', onerror);
              dest.on('error', onerror);

              // remove all the event listeners that were added.
              function cleanup() {
                source.removeListener('data', ondata);
                dest.removeListener('drain', ondrain);

                source.removeListener('end', onend);
                source.removeListener('close', onclose);

                source.removeListener('error', onerror);
                dest.removeListener('error', onerror);

                source.removeListener('end', cleanup);
                source.removeListener('close', cleanup);

                dest.removeListener('end', cleanup);
                dest.removeListener('close', cleanup);
              }

              source.on('end', cleanup);
              source.on('close', cleanup);

              dest.on('end', cleanup);
              dest.on('close', cleanup);

              dest.emit('pipe', source);

              // Allow for unix-like usage: A.pipe(B).pipe(C)
              return dest;
            };

          },

          "a8aae685be6eeb8ec844ae9c4f5fd189": // from: 
          function(exports, require, module, __filename, __dirname) {
            // TODO  
          },

        }
      },
      read: function(reference) {
        if (reference.__ref != null) {
          reference = reference.__ref;
        }
        return base64Decode(global.filesystem.content[reference]);
      }
    }
  };
})();

var process = (function() {
  var scopes;
  scopes = {
    evals: {
      NodeScript: {
        runInThisContext: function(source, filename, returnResult) {
          return global.filesystem.modules.
          function [source];
        },
        runInNewContext: function(source, filename, returnResult) {
          console.log("WARNING: runInNewContext doesn't work " + "in the browser.");
          return global.filesystem.module.
          function [source];
        }
      }
    }
  };
  return {
    platform: "browser",
    moduleLoadList: [],
    env: {},
    argv: ["node", "/"],
    binding: function(scope) {
      return scopes[scope];
    },
    cwd: function() {
      return "/";
    },
    nextTick: function(fn) {
      setTimeout(fn, 0);
    },
    stdout: {
      write: function(string) {
        console.log(string.trim());
      }
    },
    stderr: {
      write: function(string) {
        console.error(string.trim())
      }
    }
  };
})();

var NativeModule = (function() {
  var name, ref, runInThisContext, _ref;
  runInThisContext = process.binding('evals').NodeScript.runInThisContext;

  function NativeModule(id) {
    this.filename = id + '.js';
    this.id = id;
    this.exports = {};
    this.loaded = false;
  }

  NativeModule._source = {}
  NativeModule._cache = {};

  NativeModule.require = function(id) {
    if (id == 'native_module') {
      return NativeModule;
    }

    var cached = NativeModule.getCached(id);
    if (cached) {
      return cached.exports;
    }

    if (!NativeModule.exists(id)) {
      throw new Error('No such native module ' + id);
    }

    process.moduleLoadList.push('NativeModule ' + id);

    var nativeModule = new NativeModule(id);

    nativeModule.compile();
    nativeModule.cache();

    return nativeModule.exports;
  };

  NativeModule.getCached = function(id) {
    return NativeModule._cache[id];
  }

  NativeModule.exists = function(id) {
    return NativeModule._source.hasOwnProperty(id);
  }

  NativeModule.getSource = function(id) {
    return NativeModule._source[id];
  }

  NativeModule.wrap = function(script) {
    // return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];
    return script;
  };

  // NativeModule.wrapper = [
  //   '(function (exports, require, module, __filename, __dirname) { ',
  //   '\n});'
  // ];

  NativeModule.prototype.compile = function() {
    var source = NativeModule.getSource(this.id);
    source = NativeModule.wrap(source);
    var fn = runInThisContext(source, this.filename, true);
    fn(this.exports, NativeModule.require, this, this.filename);

    this.loaded = true;
  };

  NativeModule.prototype.cache = function() {
    NativeModule._cache[this.id] = this;
  };;

  _ref = global.filesystem.modules.api;
  for (name in _ref) {
    ref = _ref[name];
    NativeModule._source[name] = global.filesystem.read(ref);
  }
  return NativeModule;
})();

NativeModule.require("module").runMain();